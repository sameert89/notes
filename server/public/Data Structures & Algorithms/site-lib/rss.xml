<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Data Structures & Algorithms]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Data Structures &amp; Algorithms</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 07 Jul 2025 06:56:51 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 07 Jul 2025 06:56:50 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[index]]></title><description><![CDATA[Welcome to the Data Structure Notes. If you like my work consider subscribing to my <a data-tooltip-position="top" aria-label="https://www.youtube.com/@Sameer.Trivedi" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/@Sameer.Trivedi" target="_self">Youtube Channel</a>. Feel free to utilize them however you want!<br>Happy Coding <img class="emoji is-unresolved" draggable="false" alt="ðŸ˜‡" src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f607.svg" height="14px" target="_self" style="max-width: 100%;">!!]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Wed, 02 Jul 2025 19:27:46 GMT</pubDate><enclosure url="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f607.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f607.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Trees]]></title><description><![CDATA[
<a class="internal-link" data-href="Trees/AVL Trees.md" href="trees/avl-trees.html#_0" target="_self" rel="noopener nofollow">AVL Trees</a>
<br><a class="internal-link" data-href="Trees/Range Queries.md" href="trees/range-queries.html#_0" target="_self" rel="noopener nofollow">Range Queries</a>
<br><a class="internal-link" data-href="Trees/Red and Black Trees.md" href="trees/red-and-black-trees.html#_0" target="_self" rel="noopener nofollow">Red and Black Trees</a>
]]></description><link>trees/trees.html</link><guid isPermaLink="false">Trees/Trees.md</guid><pubDate>Wed, 02 Jul 2025 19:15:23 GMT</pubDate></item><item><title><![CDATA[Strings]]></title><description><![CDATA[
<a class="internal-link" data-href="Strings/KMP algorithm.md" href="strings/kmp-algorithm.html#_0" target="_self" rel="noopener nofollow">KMP algorithm</a>
]]></description><link>strings/strings.html</link><guid isPermaLink="false">Strings/Strings.md</guid><pubDate>Wed, 02 Jul 2025 19:15:22 GMT</pubDate></item><item><title><![CDATA[Leetcode]]></title><description><![CDATA[
<a class="internal-link" data-href="Problems/Leetcode/440 Kth lexicographically smallest number.md" href="problems/leetcode/440-kth-lexicographically-smallest-number.html#_0" target="_self" rel="noopener nofollow">440 Kth lexicographically smallest number</a>
<br><a class="internal-link" data-href="Problems/Leetcode/Divisor Game.md" href="problems/leetcode/divisor-game.html#_0" target="_self" rel="noopener nofollow">Divisor Game</a> <br><a class="internal-link" data-href="Problems/Leetcode/Divisor Game.md#Problem Statement" href="problems/leetcode/divisor-game.html#Problem_Statement_0" target="_self" rel="noopener nofollow">Problem Statement</a>
<br><a class="internal-link" data-href="Problems/Leetcode/Divisor Game.md#Approach" href="problems/leetcode/divisor-game.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a> <br><a class="internal-link" data-href="Problems/Leetcode/Divisor Game.md#Approach#DP Approach" href="problems/leetcode/divisor-game.html#Approach_0" target="_self" rel="noopener nofollow">DP Approach</a> <br><a class="internal-link" data-href="Problems/Leetcode/Is Graph Bipartite.md" href="problems/leetcode/is-graph-bipartite.html#_0" target="_self" rel="noopener nofollow">Is Graph Bipartite</a> <br><a class="internal-link" data-href="Problems/Leetcode/Is Graph Bipartite.md#Problem statement" href="problems/leetcode/is-graph-bipartite.html#Problem_statement_0" target="_self" rel="noopener nofollow">Problem statement</a> <br><a class="internal-link" data-href="Problems/Leetcode/Is Graph Bipartite.md#Problem statement#Approach" href="problems/leetcode/is-graph-bipartite.html#Problem_statement_0" target="_self" rel="noopener nofollow">Approach</a> <br><a class="internal-link" data-href="Problems/Leetcode/Miscellaneous.md" href="problems/leetcode/miscellaneous.html#_0" target="_self" rel="noopener nofollow">Miscellaneous</a>
<br><a class="internal-link" data-href="Problems/Leetcode/Nth Digit.md" href="problems/leetcode/nth-digit.html#_0" target="_self" rel="noopener nofollow">Nth Digit</a> <br><a class="internal-link" data-href="Problems/Leetcode/Nth Digit.md#Approach" href="problems/leetcode/nth-digit.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a> <br><a class="internal-link" data-href="Problems/Leetcode/Path Sum 3.md" href="problems/leetcode/path-sum-3.html#_0" target="_self" rel="noopener nofollow">Path Sum 3</a> <br><a class="internal-link" data-href="Problems/Leetcode/Path Sum 3.md#Approach" href="problems/leetcode/path-sum-3.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a> ]]></description><link>problems/leetcode/leetcode.html</link><guid isPermaLink="false">Problems/Leetcode/Leetcode.md</guid><pubDate>Wed, 02 Jul 2025 19:15:18 GMT</pubDate></item><item><title><![CDATA[GFG]]></title><description><![CDATA[
<a class="internal-link" data-href="Problems/GFG/Alien Dictionary.md" href="problems/gfg/alien-dictionary.html#_0" target="_self" rel="noopener nofollow">Alien Dictionary</a> <br><a class="internal-link" data-href="Problems/GFG/Alien Dictionary.md#Problem Statement" href="problems/gfg/alien-dictionary.html#Problem_Statement_0" target="_self" rel="noopener nofollow">Problem Statement</a>
<br><a class="internal-link" data-href="Problems/GFG/Alien Dictionary.md#Approach" href="problems/gfg/alien-dictionary.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a> <br><a class="internal-link" data-href="Problems/GFG/Alien Dictionary.md#Approach#Solution" href="problems/gfg/alien-dictionary.html#Approach_0" target="_self" rel="noopener nofollow">Solution</a> <br><a class="internal-link" data-href="Problems/GFG/Flood fill algorithm.md" href="problems/gfg/flood-fill-algorithm.html#_0" target="_self" rel="noopener nofollow">Flood fill algorithm</a> <br><a class="internal-link" data-href="Problems/GFG/Flood fill algorithm.md#Problem Statement" href="problems/gfg/flood-fill-algorithm.html#Problem_Statement_0" target="_self" rel="noopener nofollow">Problem Statement</a>
<br><a class="internal-link" data-href="Problems/GFG/Flood fill algorithm.md#Approach" href="problems/gfg/flood-fill-algorithm.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a>
<br><a class="internal-link" data-href="Problems/GFG/Flood fill algorithm.md#Solution" href="problems/gfg/flood-fill-algorithm.html#Solution_0" target="_self" rel="noopener nofollow">Solution</a> ]]></description><link>problems/gfg/gfg.html</link><guid isPermaLink="false">Problems/GFG/GFG.md</guid><pubDate>Wed, 02 Jul 2025 19:15:17 GMT</pubDate></item><item><title><![CDATA[Problems]]></title><description><![CDATA[
<a class="internal-link" data-href="Problems/GFG/GFG.md" href="problems/gfg/gfg.html#_0" target="_self" rel="noopener nofollow"><strong><em></em></strong></a>GFG <br><a class="internal-link" data-href="Problems/GFG/Alien Dictionary.md" href="problems/gfg/alien-dictionary.html#_0" target="_self" rel="noopener nofollow">Alien Dictionary</a> <br><a class="internal-link" data-href="Problems/GFG/Alien Dictionary.md#Problem Statement" href="problems/gfg/alien-dictionary.html#Problem_Statement_0" target="_self" rel="noopener nofollow">Problem Statement</a>
<br><a class="internal-link" data-href="Problems/GFG/Alien Dictionary.md#Approach" href="problems/gfg/alien-dictionary.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a> <br><a class="internal-link" data-href="Problems/GFG/Alien Dictionary.md#Approach#Solution" href="problems/gfg/alien-dictionary.html#Approach_0" target="_self" rel="noopener nofollow">Solution</a> <br><a class="internal-link" data-href="Problems/GFG/Flood fill algorithm.md" href="problems/gfg/flood-fill-algorithm.html#_0" target="_self" rel="noopener nofollow">Flood fill algorithm</a> <br><a class="internal-link" data-href="Problems/GFG/Flood fill algorithm.md#Problem Statement" href="problems/gfg/flood-fill-algorithm.html#Problem_Statement_0" target="_self" rel="noopener nofollow">Problem Statement</a>
<br><a class="internal-link" data-href="Problems/GFG/Flood fill algorithm.md#Approach" href="problems/gfg/flood-fill-algorithm.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a>
<br><a class="internal-link" data-href="Problems/GFG/Flood fill algorithm.md#Solution" href="problems/gfg/flood-fill-algorithm.html#Solution_0" target="_self" rel="noopener nofollow">Solution</a> <br><a class="internal-link" data-href="Problems/Leetcode/Leetcode.md" href="problems/leetcode/leetcode.html#_0" target="_self" rel="noopener nofollow"><strong><em></em></strong></a>Leetcode <br><a class="internal-link" data-href="Problems/Leetcode/440 Kth lexicographically smallest number.md" href="problems/leetcode/440-kth-lexicographically-smallest-number.html#_0" target="_self" rel="noopener nofollow">440 Kth lexicographically smallest number</a>
<br><a class="internal-link" data-href="Problems/Leetcode/Divisor Game.md" href="problems/leetcode/divisor-game.html#_0" target="_self" rel="noopener nofollow">Divisor Game</a> <br><a class="internal-link" data-href="Problems/Leetcode/Divisor Game.md#Problem Statement" href="problems/leetcode/divisor-game.html#Problem_Statement_0" target="_self" rel="noopener nofollow">Problem Statement</a>
<br><a class="internal-link" data-href="Problems/Leetcode/Divisor Game.md#Approach" href="problems/leetcode/divisor-game.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a> <br><a class="internal-link" data-href="Problems/Leetcode/Divisor Game.md#Approach#DP Approach" href="problems/leetcode/divisor-game.html#Approach_0" target="_self" rel="noopener nofollow">DP Approach</a> <br><a class="internal-link" data-href="Problems/Leetcode/Is Graph Bipartite.md" href="problems/leetcode/is-graph-bipartite.html#_0" target="_self" rel="noopener nofollow">Is Graph Bipartite</a> <br><a class="internal-link" data-href="Problems/Leetcode/Is Graph Bipartite.md#Problem statement" href="problems/leetcode/is-graph-bipartite.html#Problem_statement_0" target="_self" rel="noopener nofollow">Problem statement</a> <br><a class="internal-link" data-href="Problems/Leetcode/Is Graph Bipartite.md#Problem statement#Approach" href="problems/leetcode/is-graph-bipartite.html#Problem_statement_0" target="_self" rel="noopener nofollow">Approach</a> <br><a class="internal-link" data-href="Problems/Leetcode/Miscellaneous.md" href="problems/leetcode/miscellaneous.html#_0" target="_self" rel="noopener nofollow">Miscellaneous</a>
<br><a class="internal-link" data-href="Problems/Leetcode/Nth Digit.md" href="problems/leetcode/nth-digit.html#_0" target="_self" rel="noopener nofollow">Nth Digit</a> <br><a class="internal-link" data-href="Problems/Leetcode/Nth Digit.md#Approach" href="problems/leetcode/nth-digit.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a> <br><a class="internal-link" data-href="Problems/Leetcode/Path Sum 3.md" href="problems/leetcode/path-sum-3.html#_0" target="_self" rel="noopener nofollow">Path Sum 3</a> <br><a class="internal-link" data-href="Problems/Leetcode/Path Sum 3.md#Approach" href="problems/leetcode/path-sum-3.html#Approach_0" target="_self" rel="noopener nofollow">Approach</a> ]]></description><link>problems/problems.html</link><guid isPermaLink="false">Problems/Problems.md</guid><pubDate>Wed, 02 Jul 2025 19:15:16 GMT</pubDate></item><item><title><![CDATA[Miscellaneous]]></title><description><![CDATA[
<a class="internal-link" data-href="Miscellaneous/Complexity Theory (P, NP, NP hard and NP complete).md" href="miscellaneous/complexity-theory-(p,-np,-np-hard-and-np-complete).html#_0" target="_self" rel="noopener nofollow">Complexity Theory (P, NP, NP hard and NP complete)</a> <br><a class="internal-link" data-href="Miscellaneous/Complexity Theory (P, NP, NP hard and NP complete).md#NP Hard problems" href="miscellaneous/complexity-theory-(p,-np,-np-hard-and-np-complete).html#NP_Hard_problems_0" target="_self" rel="noopener nofollow">NP Hard problems</a>
<br><a class="internal-link" data-href="Miscellaneous/Complexity Theory (P, NP, NP hard and NP complete).md#NP complete" href="miscellaneous/complexity-theory-(p,-np,-np-hard-and-np-complete).html#NP_complete_0" target="_self" rel="noopener nofollow">NP complete</a> <br><a class="internal-link" data-href="Miscellaneous/Complexity Theory (P, NP, NP hard and NP complete).md#NP complete#Reduction" href="miscellaneous/complexity-theory-(p,-np,-np-hard-and-np-complete).html#NP_complete_0" target="_self" rel="noopener nofollow">Reduction</a> <br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#_0" target="_self" rel="noopener nofollow">Galen's guide to being a successful competitive programmer</a> <br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#General" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#General_0" target="_self" rel="noopener nofollow">General</a> <br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#General#The Learning Mindset" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#General_0" target="_self" rel="noopener nofollow">The Learning Mindset</a>
<br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#General#Mistakes" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#General_0" target="_self" rel="noopener nofollow">Mistakes</a> <br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Practice" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Practice_0" target="_self" rel="noopener nofollow">Practice</a>
<br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Rating based advice" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Rating_based_advice_0" target="_self" rel="noopener nofollow">Rating based advice</a> <br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Rating based advice#0-999" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Rating_based_advice_0" target="_self" rel="noopener nofollow">0-999</a>
<br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Rating based advice#1000-1199" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Rating_based_advice_0" target="_self" rel="noopener nofollow">1000-1199</a>
<br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Rating based advice#1200-1399" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Rating_based_advice_0" target="_self" rel="noopener nofollow">1200-1399</a>
<br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Rating based advice#1400-1599" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Rating_based_advice_0" target="_self" rel="noopener nofollow">1400-1599</a>
<br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Rating based advice#1600-1899" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Rating_based_advice_0" target="_self" rel="noopener nofollow">1600-1899</a>
<br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Rating based advice#1900-2099" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Rating_based_advice_0" target="_self" rel="noopener nofollow">1900-2099</a> <br><a class="internal-link" data-href="Miscellaneous/Galen's guide to being a successful competitive programmer.md#Conclusion" href="miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html#Conclusion_0" target="_self" rel="noopener nofollow">Conclusion</a> <br><a class="internal-link" data-href="Miscellaneous/Mathematical Induction.md" href="miscellaneous/mathematical-induction.html#_0" target="_self" rel="noopener nofollow">Mathematical Induction</a> <br><a class="internal-link" data-href="Miscellaneous/Mathematical Induction.md#Statement" href="miscellaneous/mathematical-induction.html#Statement_0" target="_self" rel="noopener nofollow">Statement</a>
<br><a class="internal-link" data-href="Miscellaneous/Mathematical Induction.md#Steps to prove" href="miscellaneous/mathematical-induction.html#Steps_to_prove_0" target="_self" rel="noopener nofollow">Steps to prove</a>
<br><a class="internal-link" data-href="Miscellaneous/Mathematical Induction.md#Greedy Problems" href="miscellaneous/mathematical-induction.html#Greedy_Problems_0" target="_self" rel="noopener nofollow">Greedy Problems</a> <br><a class="internal-link" data-href="Miscellaneous/Policy Based Data Structures.md" href="miscellaneous/policy-based-data-structures.html#_0" target="_self" rel="noopener nofollow">Policy Based Data Structures</a>
Resources <br><a class="internal-link" data-href="Miscellaneous/Resources/04-greedy.pdf" href="miscellaneous/resources/04-greedy.html#_0" target="_self" rel="noopener nofollow">04-greedy</a>
<br><a class="internal-link" data-href="Miscellaneous/Resources/Roadmap Resources.pdf" href="miscellaneous/resources/roadmap-resources.html#_0" target="_self" rel="noopener nofollow">Roadmap Resources</a> ]]></description><link>miscellaneous/miscellaneous.html</link><guid isPermaLink="false">Miscellaneous/Miscellaneous.md</guid><pubDate>Wed, 02 Jul 2025 19:15:13 GMT</pubDate></item><item><title><![CDATA[Leetcode Contests]]></title><description><![CDATA[
Weekly 359 <a class="internal-link" data-href="Leetcode Contests/Weekly/359/Find the longest equal subarray.md" href="leetcode-contests/weekly/359/find-the-longest-equal-subarray.html#_0" target="_self" rel="noopener nofollow">Find the longest equal subarray</a>
<br><a class="internal-link" data-href="Leetcode Contests/Weekly/359/Maximize Profit as a Salesman.md" href="leetcode-contests/weekly/359/maximize-profit-as-a-salesman.html#_0" target="_self" rel="noopener nofollow">Maximize Profit as a Salesman</a> ]]></description><link>leetcode-contests/leetcode-contests.html</link><guid isPermaLink="false">Leetcode Contests/Leetcode Contests.md</guid><pubDate>Wed, 02 Jul 2025 19:15:03 GMT</pubDate></item><item><title><![CDATA[Arrays]]></title><description><![CDATA[
<a class="internal-link" data-href="Arrays/Bubble Sort.md" href="arrays/bubble-sort.html#_0" target="_self" rel="noopener nofollow">Bubble Sort</a>
<br><a class="internal-link" data-href="Arrays/Selection Sort.md" href="arrays/selection-sort.html#_0" target="_self" rel="noopener nofollow">Selection Sort</a>
]]></description><link>arrays/arrays.html</link><guid isPermaLink="false">Arrays/Arrays.md</guid><pubDate>Wed, 02 Jul 2025 19:14:54 GMT</pubDate></item><item><title><![CDATA[Tries]]></title><description><![CDATA[Tries are k-ary trees used for searching keys optimally, they are also known as radix trees/prefix trees.
re-trie-valBelow is a Trie implementation for the english words. This is slightly different from trees for effective implementation(It has no value in itself, the alphabet added is determined by its children). Each node (block of memory) has one ore more of the 26 alphabets. And a mark attribute, that marks if a word ends at this node. So position 3 is not None, it will have a pointer to the next node of the Trie.
Rootclass TrieNode: def __init__(self): self.children = {} self.eow = False # end of word?
class Trie: def __init__(self): self.root = TrieNode() def insert(self, key): N = len(key) trav = self.root for ch in key: if ch not in trav.children: trav.children[ch] = TrieNode() trav = trav.children[ch] trav.eow = True def search(self, key): N = len(key) trav = self.root for i, ch in enumerate(key): if ch not in trav.children: return False trav = trav.children[ch] return trav.eow
]]></description><link>tries/tries.html</link><guid isPermaLink="false">Tries/Tries.md</guid><pubDate>Wed, 02 Jul 2025 18:54:17 GMT</pubDate></item><item><title><![CDATA[Range Queries]]></title><description><![CDATA[You are given an array of N elements and you are also given Q queries, each query has a range [l, r] and you have to find perform whatever the query is in that range in the array and return the results.Example: You have to calculate the minimum number for each query. Simply iterate from l to r and find out the minimum for each of them, the time complexity in this case is O(N*Q) which will result in TLE for large input sizes. The idea is to utilize a complete binary tree based data structure for storing the symmetric range queries and then calculating the values from the tree. A node has the following attributes.struct segTreeNode{ int result, index; // result of the query operation for curr range pair&lt;int, int&gt; range; segTreeNode *left, *right;
}
Since this is a complete binary tree, it is beneficial for us to store it in an array.vector&lt;int&gt; segTree(4*N);
For an array of N elements it has been mathematically proven that a segment tree of 4N nodes is enough.
In a zero indexed segment tree the root node has the index 0, like heaps the following applies:leftChild = 2*i + 1
rightChild = 2*i + 2
The root carries the answer for the whole range [0, N-1] and then we keep splitting the ranges in half for the left and right children.
Drawing 2023-09-13 15.28.51.excalidraw<img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;"> Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. <img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;">1 5 2 0 3 4 0 1 2 3 4 5 [3, 5] 2 [0, 5] 0 [5, 5] 6 [0, 2] 1 [4, 4] 13 Above picture gives a representation of a segment tree.Below is the code for building the segment tree.There are three rules to remember for calculating the results.
Given a query [low, high] we start from the root node. The following cases are possible:
Case 1: No overlap In this case the range of the current node does not overlap with the query in this case return an answer that does not affect the outcome. For example: for minimum value you may return infinity and for the sum problem you should return 0.
Case 2: Full Overlap In this case the range of the current node is the same as the query range, just return the value stored in the node.
Case 3: Partial Overlap In this case the range of the current node partially overlaps with the given range, partial means some part lies in and some part lies out. In this case you call the query for the left and right child and combine the results.
Below is the code for finding the minimum value queries.Sometimes you may need to change the value of a certain index i of the array, instead of building the entire tree again we can use a point update algorithm to do it.1. Start from the root node.
2. Check if the current Node is a leaf node range = the index to be updated.
3. If yes then change the answer in the tree and return it, else just return.
4. If the node is not a leaf node check whether the node lies in left range or right child range and call update accordingly. root.val = update(root.left) if i lies in range of root.left else root.val = update(root.right)
]]></description><link>trees/range-queries.html</link><guid isPermaLink="false">Trees/Range Queries.md</guid><pubDate>Wed, 02 Jul 2025 18:54:15 GMT</pubDate><enclosure url="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[AVL Trees]]></title><description><![CDATA[Named after Adelson, Velsky and Landis. AVL Trees are height balanced binary search trees. These are in the same criteria <a data-href="Red and Black Trees" href="trees/red-and-black-trees.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Red and Black Trees</a> and are used for maintaining a sorted collection with efficient insertion, deletion and search.
They have more rigid balancing criteria than RBTs and are used when operation times need to be strict. The caveat is that they require larger number of rotations while insertion compared to RBTs.
This balancing is decided by balance factor.
For a balanced BST, the following is true for each node.
<br>Simply perform the <a data-href="Insertion in a BST" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Insertion in a BST</a>. This may create imbalance on some of the nodes. See the diagram below:Drawing 2023-10-01 22.04.16.excalidrawDepending upon the node at which imbalance is caused and the place where the new node is inserted, there are 4 types of imbalances possible.LL Imbalance: Inserted node is towards immediate left and then anywhere in the left of the immediate left.
LR Imbalance: Inserted node is toward immediate left and then anywhere in the right of the immediate left.
RL Imbalance: The RL imbalance occurs when a node is inserted towards the immediate right child of its parent and then anywhere in the left subtree of the immediate right child.
RR Imbalance: The RR imbalance occurs when a node is inserted towards the immediate right child of its parent and then anywhere in the right subtree of the immediate right child.
Drawing 2023-10-01 22.21.21.excalidrawWe perform rotations to fix these imbalances. Rotation is always done on 3 nodes at a time.
Drawing 2023-10-01 22.28.13.excalidrawAlways choose three nodes for rotations. The rotations have been shown for a large tree. The imbalance is an LL imbalance which is caused by an insertion somewhere in the C right sub (Right is still LL, I am not wrong think about it).Drawing 2023-10-01 23.12.08.excalidraw]]></description><link>trees/avl-trees.html</link><guid isPermaLink="false">Trees/AVL Trees.md</guid><pubDate>Wed, 02 Jul 2025 18:54:14 GMT</pubDate></item><item><title><![CDATA[Stacks]]></title><description><![CDATA[A stack is a LIFO data structure (Last in first out). It means the element that is added last is taken out first, like a stack of plates at a wedding buffet.Below is the implementation of a stack in C#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
struct stack { int size, top; int *base;
};
struct stack *new_stack(int n){ struct stack* st = malloc(sizeof(struct stack)); st-&gt;size = n; st-&gt;top = -1; st-&gt;base = malloc(sizeof(int) * n); memset(st-&gt;base, 0, n*sizeof(int)); return st;
}
int top(struct stack *st){ if(st-&gt;top == -1){ printf("%s", "Underflow"); return -1; } else if(st-&gt;top == st-&gt;size) { printf("%s", "Overflow"); return -1; } else { return st-&gt;base[st-&gt;top]; }
}
int pop(struct stack *st){ if(st-&gt;top == -1){ printf("%s", "Underflow"); return -1; } else { int top_val = st-&gt;base[st-&gt;top]; st-&gt;top--; return top_val; }
}
void push (struct stack *st, int val) { if (st-&gt;top == st-&gt;size) { printf("%s", "Overflow"); } else { st-&gt;top++; st-&gt;base[st-&gt;top] = val; }
}
int main(){ int n = 10; struct stack *st = new_stack(n); top(st); push(st, 55); printf("%d", top(st)); printf("%d", pop(st)); top(st);
} ]]></description><link>stacks/stacks.html</link><guid isPermaLink="false">Stacks/Stacks.md</guid><pubDate>Wed, 02 Jul 2025 18:54:13 GMT</pubDate></item><item><title><![CDATA[Queues]]></title><description><![CDATA[A queue is a FIFO data structure (First in First Out) The element which is inserted first is removed first.Have you stood in the line for getting something? The person at the front of the queue, gets things done first and comes out of the queue. If any new person wants to join they must do so at the back of the queue (unless they are total jerks and cut into the queue).
below is the implementation of a queue in python.I mean there are overflow and underflow conditions in a fixed size queue well the below one is dynamic implementation which is used just about everywhere. I am using arrays, but something like a linked list would be way more efficient.class queue: def __init__(self): self.base = [] def __len__(self): return len(self.base) def front(self): if self.base: return self.base[0] else: raise IndexError("Underflow, Queue is empty") def push(self, val): self.base.append(val) def pop(self): if self.base: return self.base.pop(0) else: raise IndexError("Underflow, Queue is empty")
CPP comes with STL queues so use them whenever needed.Quick note on try catch and except/throw(cpp). throw is used for throwing errors in code if something is wrong, try and catch are just wrappers that handle the error, you try a piece of code if there is the problem a nicely written code should throw some error which is detected by the catch block and then passed on to the catch block. And then their is finally which gets executed anyways.There are also doubly ended queues called deques which can serve both the purpose of deque and stack.I hate this from the bottom of my heart. I always write shitty code for this, here is a clean one for you tho.Important Logic, rear and front are going to always loop around if they go out of range.Drawing 2023-08-31 21.48.45.excalidraw<img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;"> Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. <img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;">capacity = 4 front == rear = -1 0 1 2 3 11 class MyCircularQueue: def __init__(self, k: int): self.capacity = k self.queue = [0] * k self.front = self.rear = -1 def enQueue(self, value: int) -&gt; bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value return True def deQueue(self) -&gt; bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.capacity return True def Front(self) -&gt; int: if self.isEmpty(): return -1 return self.queue[self.front] def Rear(self) -&gt; int: if self.isEmpty(): return -1 return self.queue[self.rear] def isEmpty(self) -&gt; bool: return self.front == -1 def isFull(self) -&gt; bool: return (self.rear + 1) % self.capacity == self.front <br>Read More about heap queues <a data-href="Heaps" href="heaps/heaps.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Heaps</a>]]></description><link>queues/queues.html</link><guid isPermaLink="false">Queues/Queues.md</guid><pubDate>Wed, 02 Jul 2025 18:54:13 GMT</pubDate><enclosure url="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Path Sum 3]]></title><description><![CDATA[<a href=".?query=tag:binary-tree" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#binary-tree">#binary-tree</a> <a href=".?query=tag:prefix-sum" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#prefix-sum">#prefix-sum</a>
Given the&nbsp;root&nbsp;of a binary tree and an integer&nbsp;targetSum, return&nbsp;the number of paths where the sum of the values&nbsp;along the path equals&nbsp;targetSum.The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.Example 2:Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3Constraints:
The number of nodes in the tree is in the range&nbsp;[0, 1000].
-109 &lt;= Node.val &lt;= 109
-1000 &lt;= targetSum &lt;= 1000
The logic is to use a prefix sum frequency map, that tracks the number of times we have found
10-10105tqrget = 5path sum = 15, need to remove 10can remove this 10 so 3 nodes make the pathcan remove this 10 as well so path wilk be just 5
a particular running sum, for each currSum we need to remove some part to make it equal to targetSum.currSum - x = targetSum =&gt; x = currSum - targetSum the frequency map tells us how many times this has occurred in the particular branch.The initial value is {0, 1} because an empty tree has 0 sum.class Solution: def pathSum(self, root: Optional[TreeNode], targetSum: int, currSum = 0, prefixSum = defaultdict(int, [(0, 1)]) )-&gt; int: if root is None: return 0 currSum += root.val count = prefixSum[currSum - targetSum] # branch sum, you reached upto current branch so your sum in currSum you try to subtract a previous branch that is how many times you can get that exact subtraction value prefixSum[currSum] += 1 count += self.pathSum(root.left, targetSum, currSum, prefixSum) + \ self.pathSum(root.right, targetSum, currSum, prefixSum) prefixSum[currSum] -= 1 # Backtrack to avoid affecting other paths return count
]]></description><link>problems/leetcode/path-sum-3.html</link><guid isPermaLink="false">Problems/Leetcode/Path Sum 3.md</guid><pubDate>Wed, 02 Jul 2025 18:54:13 GMT</pubDate><enclosure url="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Nth Digit]]></title><description><![CDATA[Given an infinite sequence of integers return the nth digit of the sequence.
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...
from 1 to 9 the n itself is the digit but the 10th digit is 1 and 11th digit is 0 1-0 and 12th digit is again 1 and so on.There is one careful observation to be made here about the number of x digit numbers present in the sequenceNumber of 1 digit numbers = 9 {1 to 9}
Number of 2 digit numbers = 90 {10 to 99}
Number of 3 digit numbers = 900 {100 to 999}
.
.
.
Number of x digit numbers = 9 * (10 ^ (x - 1)) {10 ^ (x - 1) to 10 ^ x - 1}
class Solution: def findNthDigit(self, n: int) -&gt; int: if n &lt; 10: return n n -= 1 # convert to 0 based index digit_length = 1 start = 1 while n &gt;= 9 * digit_length * start: n -= 9 * digit_length * start digit_length += 1 start *= 10 num = start + n // digit_length digit_index = n % digit_length return int(str(num)[digit_index])
]]></description><link>problems/leetcode/nth-digit.html</link><guid isPermaLink="false">Problems/Leetcode/Nth Digit.md</guid><pubDate>Wed, 02 Jul 2025 18:54:13 GMT</pubDate></item><item><title><![CDATA[Miscellaneous]]></title><description><![CDATA[Given a&nbsp;square&nbsp;matrix&nbsp;mat, return the sum of the matrix diagonals.Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.Example 1:<img src="https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Given the&nbsp;root&nbsp;of a binary tree, invert the tree, and return&nbsp;its root.Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Input: root = [2,1,3]
Output: [2,3,1]Given an array of integers&nbsp;temperatures&nbsp;represents the daily temperatures, return&nbsp;an array&nbsp;answer&nbsp;such that&nbsp;answer[i]&nbsp;is the number of days you have to wait after the&nbsp;ith&nbsp;day to get a warmer temperature. If there is no future day for which this is possible, keep&nbsp;answer[i] == 0&nbsp;instead.Example 1:Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]]]></description><link>problems/leetcode/miscellaneous.html</link><guid isPermaLink="false">Problems/Leetcode/Miscellaneous.md</guid><pubDate>Wed, 02 Jul 2025 18:54:12 GMT</pubDate><enclosure url="https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Is Graph Bipartite]]></title><description><![CDATA[<a href=".?query=tag:graphs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#graphs">#graphs</a> <a href=".?query=tag:cycle_detection" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#cycle_detection">#cycle_detection</a>There is an&nbsp;undirected&nbsp;graph with&nbsp;n&nbsp;nodes, where each node is numbered between&nbsp;0&nbsp;and&nbsp;n - 1. You are given a 2D array&nbsp;graph, where&nbsp;graph[u]&nbsp;is an array of nodes that node&nbsp;u&nbsp;is adjacent to. More formally, for each&nbsp;v&nbsp;in&nbsp;graph[u], there is an undirected edge between node&nbsp;u&nbsp;and node&nbsp;v. The graph has the following properties:
There are no self-edges (graph[u]&nbsp;does not contain&nbsp;u).
There are no parallel edges (graph[u]&nbsp;does not contain duplicate values).
If&nbsp;v&nbsp;is in&nbsp;graph[u], then&nbsp;u&nbsp;is in&nbsp;graph[v]&nbsp;(the graph is undirected).
The graph may not be connected, meaning there may be two nodes&nbsp;u&nbsp;and&nbsp;v&nbsp;such that there is no path between them.
A graph is&nbsp;bipartite&nbsp;if the nodes can be partitioned into two independent sets&nbsp;A&nbsp;and&nbsp;B&nbsp;such that&nbsp;every&nbsp;edge in the graph connects a node in set&nbsp;A&nbsp;and a node in set&nbsp;B.Return&nbsp;true&nbsp;if and only if it is&nbsp;bipartite.Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
Output: false
Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Input: graph = [[1,3],[0,2],[1,3],[0,2]]
Output: true
Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.Constraints:
graph.length == n
1 &lt;= n &lt;= 100
0 &lt;= graph[u].length &lt; n
0 &lt;= graph[u][i] &lt;= n - 1
graph[u]&nbsp;does not contain&nbsp;u.
All the values of&nbsp;graph[u]&nbsp;are&nbsp;unique.
If&nbsp;graph[u]&nbsp;contains&nbsp;v, then&nbsp;graph[v]&nbsp;contains&nbsp;u.
This problem is just a cycle detection problem for undirected graphs.<br>
Check out <a data-href="Graphs" href="graphs/graphs.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graphs</a> for reading about bipartite graphs.
Any algorithm can be used.]]></description><link>problems/leetcode/is-graph-bipartite.html</link><guid isPermaLink="false">Problems/Leetcode/Is Graph Bipartite.md</guid><pubDate>Wed, 02 Jul 2025 18:54:12 GMT</pubDate><enclosure url="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Divisor Game]]></title><description><![CDATA[<a href=".?query=tag:math" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#math">#math</a> <a href=".?query=tag:dynamic_programming" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dynamic_programming">#dynamic_programming</a> <a href=".?query=tag:1D_dp" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#1D_dp">#1D_dp</a>Alice and Bob take turns playing a game, with Alice starting first.Initially, there is a number&nbsp;n&nbsp;on the chalkboard. On each player's turn, that player makes a move consisting of:
Choosing any&nbsp;x&nbsp;with&nbsp;0 &lt; x &lt; n&nbsp;and&nbsp;n % x == 0.
Replacing the number&nbsp;n&nbsp;on the chalkboard with&nbsp;n - x.
Also, if a player cannot make a move, they lose the game.Return&nbsp;true&nbsp;if and only if Alice wins the game, assuming both players play optimally.Example 1:Input: n = 2
Output: true
Explanation: Alice chooses 1, and Bob has no more moves.Example 2:Input: n = 3
Output: false
Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.Constraints:
1 &lt;= n &lt;= 1000
it can be easily solved by observing the even odd relation to the winner, the one who gets an odd number loses always since there is no divisors in the range (0, 1). Anyone who gets even can give the other person odd by choosing 1 and force them to lose. So even is winner always.Let's say dp[i] = true when a players wins and 0 if they lose, then for any number n if there exists an x such that n%x == 0 and it is the losing position for the other player if we can win. Since Alice gets the first pick for every n (DP n varies) she will try to find such index where she can move the game where dp[i] is false so that Bob goes and loses from that point. Now It is just a matter of checking all factors and the losing positions for Bob in that those. class Solution: def divisorGame(self, n: int) -&gt; bool: if n == 1: return False # base case dp = [0]*(n + 1) dp[2] = True # base case for i in range(3, n + 1): j = 1 while j*j &lt; i: # factors can only lie upto sqrt(n) if i%j == 0 and dp[i - j] == 0: dp[i] = 1; break j += 1 return dp[n]
]]></description><link>problems/leetcode/divisor-game.html</link><guid isPermaLink="false">Problems/Leetcode/Divisor Game.md</guid><pubDate>Wed, 02 Jul 2025 18:54:11 GMT</pubDate></item><item><title><![CDATA[440 Kth lexicographically smallest number]]></title><description><![CDATA[<a href=".?query=tag:trees" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#trees">#trees</a> <a href=".?query=tag:hard" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#hard">#hard</a>
This is a followup of the return lexicographically sorted list of natural numbers up to n. There you could just sort it by converting each number to string, but the restraint was to do it in time.I wrote a method to just do that, bascially a next method that will tell what the next number will be given a current number. The implementation of the next function is belowdef next(curr: int, n: int) -&gt; int: if next * 10 &lt;= n: return next * 10 else: while next % 10 == 9 and next + 1 &gt; n: next //= 10 return next + 1
But this followup question presents a maximum length of making it impossible to do it in O(N).The idea to solve this problem is to look at how the numbers are arranged in 2D, below drawing shows a careful observation for a given range.N = 1301102100311We see an binary tree structure that is being followed here, we only need to figure out a way to traverse to the branch which has our kth number.To get the subtree for each number we append the digits to the number. Let's analyse the number of elements in each level of this tree.Clearly for getting the lexicographical order we need to perform preorder traversal of this tree.
It will be beneficial to identify which level will given number fall in:Say N = 13, the leftmost leaf will be 10]]></description><link>problems/leetcode/440-kth-lexicographically-smallest-number.html</link><guid isPermaLink="false">Problems/Leetcode/440 Kth lexicographically smallest number.md</guid><pubDate>Wed, 02 Jul 2025 18:54:11 GMT</pubDate></item><item><title><![CDATA[Flood fill algorithm]]></title><description><![CDATA[<a href=".?query=tag:graphs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#graphs">#graphs</a> <a href=".?query=tag:implicit-bfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#implicit-bfs">#implicit-bfs</a> <a href=".?query=tag:implicit-dfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#implicit-dfs">#implicit-dfs</a>An&nbsp;image&nbsp;is represented by a 2-D array of integers, each integer representing the pixel value of the image.Given a coordinate&nbsp;(sr, sc)&nbsp;representing the starting pixel (row and column) of the flood fill, and a pixel value&nbsp;newColor, "flood fill" the image.To perform a&nbsp;"flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the&nbsp;same color&nbsp;as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the&nbsp;same color&nbsp;as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.Example 1:Input: image = {{1,1,1},{1,1,0},{1,0,1}},
sr = 1, sc = 1, newColor = 2.
Output: {{2,2,2},{2,2,0},{2,0,1}}
Explanation: From the center of the image
(with position (sr, sc) = (1, 1)), all
pixels connected by a path of the same color
as the starting pixel are colored with the new
color.Note the bottom corner is not colored 2,
because it is not 4-directionally connected to
the starting pixel.Your Task:
You don't need to read or print anything. Your task is to complete the function&nbsp;floodFill()&nbsp;which takes image, sr, sc and newColor as input parameter and returns the image after flood filling. &nbsp;Expected Time Compelxity:&nbsp;O(nm)
Expected Space Complexity:&nbsp;O(nm) &nbsp;Constraints:
1 &lt;= n &lt;= m &lt;= 100
0 &lt;= pixel values &lt;= 10
0 &lt;= sr &lt;= (n-1)
0 &lt;= sc &lt;= (m-1)just use implicit bfs/dfs and keep track of colors for the thing. We are allowed to modify the matrix itself here, best practice is to not modify the source data.from collections import deque
# Snippet created by sameer 21-08-2023
def valid_neighbors(x, y, graph): m, n = len(graph), len(graph[0]) delta = [(-1,0),(0,-1),(0,1),(1,0)] neighbors = [] for dx,dy in delta: r, c = x + dx, y + dy if 0&lt;=r&lt;m and 0&lt;=c&lt;n: neighbors.append((r,c)) return neighbors def bfs_impl(matrix, vertex, newColor): sr, sc = vertex source_color = matrix[sr][sc] matrix[sr][sc] = newColor q = deque() q.append(vertex) while q: x, y = q.popleft() for r, c in valid_neighbors(x, y, matrix): if matrix[r][c] != newColor and matrix[r][c] == source_color: q.append((r, c)) matrix[r][c] = newColor class Solution: def floodFill(self, image, sr, sc, newColor): bfs_impl(image, (sr, sc), newColor) return image ]]></description><link>problems/gfg/flood-fill-algorithm.html</link><guid isPermaLink="false">Problems/GFG/Flood fill algorithm.md</guid><pubDate>Wed, 02 Jul 2025 18:54:11 GMT</pubDate></item><item><title><![CDATA[Policy Based Data Structures]]></title><description><![CDATA[The g++ compiler supports a lot of additional functionality that is not the part of the official C++ standard. One of these is the PBDS short for the policy based data structures. These are designed for high performance and often times have useful features not available in the STL. They are designed to interface with the STL containers so that both of them can be used in conjunction.#include &lt;ext/pb_ds/assoc_container.hpp&gt; // Common file
// The data structure specific header file
using namespace __gnu_pbds;
Ordered set is like the std::set but it supports additional features:
Getting the cardinal number of an element i.e. the index of the element in the set in time. Normal sets need linear time to do this and there is no concept of index in the normal sets.
Getting the number of elements smaller than the current element in time. Following code demonstrates the usage.// Program showing a policy-based data structure.
#include &lt;ext/pb_ds/assoc_container.hpp&gt; // Common file
#include &lt;ext/pb_ds/tree_policy.hpp&gt;
#include &lt;functional&gt; // for less and less_equal for multiset
#include &lt;iostream&gt;
using namespace __gnu_pbds;
using namespace std; typedef tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_set; // Driver code
int main()
{ ordered_set p; p.insert(5); p.insert(2); p.insert(6); p.insert(4); // value at 3rd index in sorted array. cout &lt;&lt; "The value at 3rd index ::" &lt;&lt; *p.find_by_order(3) &lt;&lt; endl; // index of number 6 cout &lt;&lt; "The index of number 6::" &lt;&lt; p.order_of_key(6) &lt;&lt; endl; // number 7 not in the set but it will show the // index number if it was there in sorted array. cout &lt;&lt; "The index of number seven ::" &lt;&lt; p.order_of_key(7) &lt;&lt; endl; return 0;
} ]]></description><link>miscellaneous/policy-based-data-structures.html</link><guid isPermaLink="false">Miscellaneous/Policy Based Data Structures.md</guid><pubDate>Wed, 02 Jul 2025 18:54:11 GMT</pubDate></item><item><title><![CDATA[Mathematical Induction]]></title><description><![CDATA[Mathematical Induction is a mathematical technique&nbsp;which is used to prove a statement, a formula or a theorem is true for every natural number.It can be used to prove some pain in the ass greedy algorithms in your head so that you can start coding.if holds and , then also holds.Example: There are N balls, and the first ball is red. And if nth ball is of color x then (n + 1)th ball is also of color x. Then we can conclude that all balls are red.If you topple the domino at position 0, all dominoes topple.
Induction hypothesis: Define your induction hypothesis.
Prove for Base case: Prove that your hypothesis is true for base case.
Assume hypothesis to be true of P(n)
Prove for P(n + 1) using 2 and 3
Proof for N meetings in a room<img alt="Pasted image 20230924234109.png" src="_assets/pasted-image-20230924234109.png" target="_self"><br>Following resource is excellent for understanding some most frequent and established greedy problems. More problems are in this brain in the <a href=".?query=tag:greedy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#greedy">#greedy</a> tag.]]></description><link>miscellaneous/mathematical-induction.html</link><guid isPermaLink="false">Miscellaneous/Mathematical Induction.md</guid><pubDate>Wed, 02 Jul 2025 18:54:10 GMT</pubDate><enclosure url="_assets/pasted-image-20230924234109.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="_assets/pasted-image-20230924234109.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Galen's guide to being a successful competitive programmer]]></title><description><![CDATA["No roadmap will work if you are not practicing problems the right way that is practicing to learn..." I am practicing to get better at solving. In editorials try to find out how to come up with this solutions. Try to spend as much time on a problem as you can. Think of things that you aren't already familiar with. Spend time thinking about problems, don't let your <img class="emoji is-unresolved" draggable="false" alt="ðŸ§ " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f9e0.svg" height="14px" target="_self" style="max-width: 100%;"> sit idle. Ask why more and more, why is this &amp; why is that. It is easy to lie to yourself that you are "practicing" by spending time and not deeply understanding the problems.
The best practice is the practice where you are motivated. Motivation has to be interest in the problems. Solve problems with no intentions to read the editorials. Beginners don't need to learn anything just try to come up with A,B,C solutions. Don't jump for complex algorithms for these. (skipping problems and making excuses to do it in leetcode randomizer)
Any reasonable method that does not let you deceive yourself is a good practice method. If you don't like it, it's going to be harder. Comparisons are not good, compare yourself to you 1 year earlier. Fix your health and sleep cycle, it will help only if a little. Find some friends if you can. Do not become over reliant however. Improve skills and not rating. You can take breaks it is not a crime. Practice to build confidence. Upsolve!!! Don't guess problems try to prove the solutions. Not learning from problems.
Focusing too hard on speed, for long term improvement this helps a lot.
Look for your weaknesses and work on them (topics that you suck at).
Don't jump directly into code try to build the solution and proving it to yourself. Take time to look for edge cases.
Do not misread.
Don't leave the problem without attempting, if its hard then that does not mean you cannot do it.
Problems should be difficult for you. Find the problem places in Roadmap Resources. Do what is fun.
2-4 hours a day is enough.
Daily problem quotas are bad.
Short time: 20-45 minutes, Medium time: 1-4 hours both after being stuck get to the point where you are stuck.
Try to look for though processes in editorials. Why your ideas did not work. You can read editorials line by line and think about each line for 10 minutes.
Do a healthy mix of random problems and topic based problems. Focus more on random problems.
Select random problems to solve, taking note of weaknesses. To handle a weakness, do some problems involving that weakness, then go back to random problems. If the weakness is still an issue, continue with random problems, but skewed to have more problems with that weakness. Math and basic reasoning. <br><a href=".?query=tag:math" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#math">#math</a> <a href=".?query=tag:greedy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#greedy">#greedy</a> <a href=".?query=tag:constructive" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#constructive">#constructive</a> <a href=".?query=tag:brute-force" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#brute-force">#brute-force</a> <a href=".?query=tag:searching" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#searching">#searching</a> <a href=".?query=tag:sorting" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#sorting">#sorting</a> <a href=".?query=tag:strings" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#strings">#strings</a> <a href=".?query=tag:number-theory" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#number-theory">#number-theory</a> <br><a href=".?query=tag:binary-search" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#binary-search">#binary-search</a> <a href=".?query=tag:two-pointers" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#two-pointers">#two-pointers</a>
Solve A and B smoothly (div 2) and A, B, C for div 3 contests.
Just improve reasoning, practice random problems.
Focus on weaknesses. <br><a href=".?query=tag:brute-force" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#brute-force">#brute-force</a> <a href=".?query=tag:sorting" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#sorting">#sorting</a> <a href=".?query=tag:number-theory" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#number-theory">#number-theory</a> <a href=".?query=tag:strings" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#strings">#strings</a> <a href=".?query=tag:stl" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#stl">#stl</a> <br><a href=".?query=tag:bitwise" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bitwise">#bitwise</a> <a href=".?query=tag:binary-search" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#binary-search">#binary-search</a> <a href=".?query=tag:bitwise" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bitwise">#bitwise</a> <a href=".?query=tag:dynamic_programming" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dynamic_programming">#dynamic_programming</a> <a href=".?query=tag:combinatorics" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#combinatorics">#combinatorics</a> <a href=".?query=tag:range-queries" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#range-queries">#range-queries</a>
Solve A, B fast and solve C and A-D for div 3 contests. still a lot of reasoning.
<br>above topics + <a href=".?query=tag:modular-arithmetic" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#modular-arithmetic">#modular-arithmetic</a> <a href=".?query=tag:gcd" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#gcd">#gcd</a> <a href=".?query=tag:prime-factors" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#prime-factors">#prime-factors</a> <a href=".?query=tag:prefix-sum" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#prefix-sum">#prefix-sum</a> <a href=".?query=tag:recursions" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#recursions">#recursions</a> <a href=".?query=tag:dynamic_programming" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dynamic_programming">#dynamic_programming</a> <a href=".?query=tag:graphs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#graphs">#graphs</a> <a href=".?query=tag:trees" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#trees">#trees</a> <a href=".?query=tag:bfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bfs">#bfs</a> <a href=".?query=tag:dfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dfs">#dfs</a> <a href=".?query=tag:dsu" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dsu">#dsu</a> <a href=".?query=tag:segment-trees" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#segment-trees">#segment-trees</a> <a href=".?query=tag:hashing" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#hashing">#hashing</a> Solve quickly 3 problems in div 2 for div 3 A-D or A-E.
This is not rigid you may blow some contests. You have done it, you have good practice strats.
<br>above topics + <a href=".?query=tag:tree-dp" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#tree-dp">#tree-dp</a> <a href=".?query=tag:proofs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#proofs">#proofs</a> <a href=".?query=tag:constructive" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#constructive">#constructive</a> <a href=".?query=tag:inclusion-exclusion" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#inclusion-exclusion">#inclusion-exclusion</a> <a href=".?query=tag:probability" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#probability">#probability</a> <a href=".?query=tag:shortest-path" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#shortest-path">#shortest-path</a> <a href=".?query=tag:MST" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MST">#MST</a> <a href=".?query=tag:game-theory" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#game-theory">#game-theory</a> Solve A-C consistently and quickly. Its just you and practice. <br><a href=".?query=tag:graphs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#graphs">#graphs</a> <a href=".?query=tag:toposort" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#toposort">#toposort</a> <a href=".?query=tag:expected-value" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#expected-value">#expected-value</a> <a href=".?query=tag:bitwise" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bitwise">#bitwise</a> A-D consistently in div 2 and all in div 3. new problems are based on reasoning. Knowing the basics is enough.
A-B div 1 A-E div 2.
<br><a data-href="Roadmap Resources.pdf" href="miscellaneous/resources/roadmap-resources.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Roadmap Resources.pdf</a>]]></description><link>miscellaneous/galen's-guide-to-being-a-successful-competitive-programmer.html</link><guid isPermaLink="false">Miscellaneous/Galen's guide to being a successful competitive programmer.md</guid><pubDate>Wed, 02 Jul 2025 18:54:10 GMT</pubDate><enclosure url="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f9e0.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f9e0.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Complexity Theory (P, NP, NP hard and NP complete)]]></title><description><![CDATA[P = The set of problems solvable in polynomial time. Algorithms are known to us.
NP = The set of problems for which given an answer the correctness of it can be verified in a polynomial time.
NP problems are decision based every guess is either Yes of No, and we want the correct guess yes from the computer. If we wanted a no, then that set of problems is co-NP or complementary NP.
Non deterministic means certain steps are unknown and are like a guess, The computer has to guess from a polynomial number of options and we assume that it makes a good random guess.NP problems may have a way to write a non deterministic algorithm poly time algo for solving them. (NP complete guarantee it)The boolean of formula of the form. Given a boolean formula f, can you set the inputs in such a way that the expression evaluates to a 1.
<img alt="Pasted image 20230917195830.png" src="_assets/pasted-image-20230917195830.png" target="_self">The 3-SAT problem is a subset of the sat problem in which the number of inputs is limited to 3.It was the first proven NP complete algorithm.They may or may not be NP but they are hardest of the known NP problems (as far as we know they may turn out to be), any problem which is as hard as hardest NP problem they are considered NP hard. If one np hard is solved it doesn't mean that all of them would be solved.<br>
Read More <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/NP-hardness" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/NP-hardness" target="_self">here</a>Subset of NP problems with a special property if you find solution to one of them you can solve all of them. The answers can be verified in polynomial time since it's a subset of NP. They also are a part of NP hard problems that means they are as hard as the hardest of the NP problems i.e. As we mentioned earlier np hard may or may not be np these are those proven to be np.
Some of the NP complete problems: BSAT, Travelling salesman, knapsack problem, subset sum, clique, partition subset equal sum, Hamiltonian cyclesDrawing 2023-09-17 20.42.18.excalidraw<br><img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;"> Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. <img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;">difficulty P NP NP hard NP complete (May increase) Reduction means converting one NP to other NP problems. If one NP problem is solve does not mean all of them will be solved like NP hard, only NP complete problems offer that. ]]></description><link>miscellaneous/complexity-theory-(p,-np,-np-hard-and-np-complete).html</link><guid isPermaLink="false">Miscellaneous/Complexity Theory (P, NP, NP hard and NP complete).md</guid><pubDate>Wed, 02 Jul 2025 18:54:09 GMT</pubDate><enclosure url="_assets/pasted-image-20230917195830.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="_assets/pasted-image-20230917195830.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Maximize Profit as a Salesman]]></title><description><![CDATA[<a href=".?query=tag:dynamic_programming" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dynamic_programming">#dynamic_programming</a> <a href=".?query=tag:arrays" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#arrays">#arrays</a>
Got stuck really bad here. I disproved greedy so should have started thinking about DP immediately but could not do it.
Difficulty: Medium-HardYou are given an integer&nbsp;n&nbsp;representing the number of houses on a number line, numbered from&nbsp;0&nbsp;to&nbsp;n - 1.Additionally, you are given a 2D integer array&nbsp;offers&nbsp;where&nbsp;offers[i] = [starti, endi, goldi], indicating that&nbsp;ith&nbsp;buyer wants to buy all the houses from&nbsp;starti&nbsp;to&nbsp;endi&nbsp;for&nbsp;goldi&nbsp;amount of gold.As a salesman, your goal is to&nbsp;maximize&nbsp;your earnings by strategically selecting and selling houses to buyers.Return&nbsp;the maximum amount of gold you can earn.Note&nbsp;that different buyers can't buy the same house, and some houses may remain unsold.Example 1:Input: n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]
Output: 3
Explanation: There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.
We sell houses in the range [0,0] to 1st buyer for 1 gold and houses in the range [1,3] to 3rd buyer for 2 golds.
It can be proven that 3 is the maximum amount of gold we can achieve.Example 2:Input: n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]
Output: 10
Explanation: There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.
We sell houses in the range [0,2] to 2nd buyer for 10 golds.
It can be proven that 10 is the maximum amount of gold we can achieve.Constraints:
1 &lt;= n &lt;= 105
1 &lt;= offers.length &lt;= 105
offers[i].length == 3
0 &lt;= starti&nbsp;&lt;= endi&nbsp;&lt;= n - 1
1 &lt;= goldi&nbsp;&lt;= 103
So here goes the solution...
Basically you need to sell the houses but you cannot sell the houses you have already sold. Unless you are planning to scam someone. What is the optimal way of choosing the houses?
One might think we can go greedily and try to maximize the amount of profit that we are going to get from each buyer. This can be calculated as follows. Now this does not work straight up from the first test case, no matter how you sort them you are not going to get a solution that maximizes the profit. You may chose to sell 0 to 2 only to find out you could've sold 0 and 1 to 3. I thought of merging intervals but that was in vain. So let's proceed to dynamic programming.It is a variation of the knapsack problem. You basically have 2 choices, sell to the buyer and not sell to him. However I thought of this during DP thought process but then I had to keep track of the houses that I already sold using a set or something which cannot be DPed.The solution to this problem is to use sorting and use a search to determine the next buyer if you sold one house. So if a buyer bought houses in range [x, y] then you must only sell houses that are before x-1 or after y + 1. It really helps to sort the array using the y, this way you don't have to worry about x - 1 due to left to right traversal and can use Binary Search to decrease your time to search the next buyer.class Solution: def maximizeTheProfit(self, n: int, offers: List[List[int]]) -&gt; int: profit = 0 N = len(offers) offers.sort(key = lambda x: x[0]) @cache def solve(curr = 0): if curr == N: return 0 not_sell = solve(curr + 1) sell = offers[curr][2] + \ # This is line break ðŸ˜Š solve(bisect_right(offers, offers[curr][1], lo = curr, key = lambda x: x[0])) return max(sell, not_sell) return solve()
So yeah the main logic lies in sorting the starting indices so that you can consider all the buyers in order.]]></description><link>leetcode-contests/weekly/359/maximize-profit-as-a-salesman.html</link><guid isPermaLink="false">Leetcode Contests/Weekly/359/Maximize Profit as a Salesman.md</guid><pubDate>Wed, 02 Jul 2025 18:54:09 GMT</pubDate></item><item><title><![CDATA[Find the longest equal subarray]]></title><description><![CDATA[<a href=".?query=tag:sliding_window" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#sliding_window">#sliding_window</a> <a href=".?query=tag:hashing" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#hashing">#hashing</a> <a href=".?query=tag:arrays" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#arrays">#arrays</a>Difficulty: Medium-HardYou are given a&nbsp;0-indexed&nbsp;integer array&nbsp;nums&nbsp;and an integer&nbsp;k.A subarray is called&nbsp;equal&nbsp;if all of its elements are equal. Note that the empty subarray is an&nbsp;equal&nbsp;subarray.Return&nbsp;the length of the&nbsp;longest&nbsp;possible equal subarray after deleting&nbsp;at most&nbsp;k&nbsp;elements from&nbsp;nums.A&nbsp;subarray&nbsp;is a contiguous, possibly empty sequence of elements within an array.Example 1:Input: nums = [1,3,2,3,1,3], k = 3
Output: 3
Explanation: It's optimal to delete the elements at index 2 and index 4.
After deleting them, nums becomes equal to [1, 3, 3, 3].
The longest equal subarray starts at i = 1 and ends at j = 3 with length equal to 3.
It can be proven that no longer equal subarrays can be created.Example 2:Input: nums = [1,1,2,2,1,1], k = 2
Output: 4
Explanation: It's optimal to delete the elements at index 2 and index 3.
After deleting them, nums becomes equal to [1, 1, 1, 1].
The array itself is an equal subarray, so the answer is 4.
It can be proven that no longer equal subarrays can be created.This problem seemed very easy at first, but was not able to solve it.The approach #1 that came into my mind was using the gap method. I will store the indices of each occurrence of a number and then try to find out if I can bridge the gap between them using k items.Drawing 2023-08-20 14.07.38.excalidrawI would do it for each of the numbers and try to find the maximum of it. What I had trouble thinking is the edge cases that I might get stuck on. If I bridged the gap once, I have to reconsider the possibility of having a longer thing after this that may include some of the nodes from the current elements.This was the logic that the top coders used to solve this problem as well. But they traversed all instances of the element and checked the longest possible thing from them. I did not think of this because I thought it would for sure cause TLE.class Solution: def longestEqualSubarray(self, nums: List[int], k: int) -&gt; int: idx_map = defaultdict(list) max_len = 0 for idx, num in enumerate(nums): idx_map[num].append(idx) print(idx_map) for v in idx_map.values(): end = 0 for i in range(len(v)): while end &lt; len(v) and v[end] - v[i] - (end - i) &lt;= k: end += 1 max_len = max(max_len, end - i) return max_len
Things to understand:
v[end] - v[i] - (end - i) This calculates the gap between things
Drawing 2023-08-20 14.18.38.excalidrawSee the image, this statement handles then no gap and gap case to calculate the correct gap.
2. Why does it not cause TLE? Because end is not reinitialized before the for loop. So i will move forward with a fixed end after it was filled by a previous i and end will not increment or get to a longer thingy before we hit a gap which we can bridge.O(N) Every element is visited thrice because of the index map creation and the traversal at the bottom. using i and end.
O(N) Due to the index map.This was a tricky one, I definitely have less practice with sliding window so am terrible at identifying these problems.
The window tries to eat elements one by one towards the right. If it is eating one type of elements max_freq, it is going to be chilling. But if it eats some other element that is not max_freq, it will get a strike and after k strikes it is sick enough that it has to remove the element at the back. The affinity of this window is toward the most frequent element. This is the only dish that it can eat. But its affinity may change over the time if it eats way too much of B than A &amp; B becomes the most_freq.class Solution: def longestEqualSubarray(self, A: List[int], k: int) -&gt; int: maxf = i = 0 count = Counter() for j in range(len(A)): count[A[j]] += 1 maxf = max(maxf, count[A[j]]) if j - i + 1 - maxf &gt; k: # bad food = mouth - ass + 1 - good_food count[A[i]] -= 1 i += 1 return maxf
]]></description><link>leetcode-contests/weekly/359/find-the-longest-equal-subarray.html</link><guid isPermaLink="false">Leetcode Contests/Weekly/359/Find the longest equal subarray.md</guid><pubDate>Wed, 02 Jul 2025 18:54:09 GMT</pubDate></item><item><title><![CDATA[Heaps]]></title><description><![CDATA[Heap is a tree base data structure in which the tree is a complete binary tree. It follows a special heap order property.Complete Binary Tree: A binary tree in which all levels are filled except possibly the last one. The fill order is left to right.
A complete binary Tree is always a balanced binary tree, but the reverse may not be trueDrawing 2023-09-04 16.48.47.excalidrawHeap order property: For a min heap the every node is smaller than all of its children. For a max heap every node is larger than all of its children.Drawing 2023-09-04 16.52.05.excalidrawAlthough heaps are binary trees, it is more convenient and useful to store them in arrays. It is possible only because it's a complete binary tree.The above min heap can be represented in an array as follows:vector&lt;int&gt; myHeap = {10, 11, 12, 13, 14, 15, 16};
For every index i the children of i are present at 2*i + 1 &amp; 2*i + 2. For every child c its parent is at (c-1)//2. Keep it in mind that this is for 0 based indexing. For 1 based indexing the values are 2*i, 2*i + 1, c//2.Insertion operation in a heap can be performed in O(log(N)) time.void heappush(vector&lt;int&gt; &amp;heap, int val) { heap.push_back(val); int N = heap.size(); int childIndex = N - 1, parIndex = (childIndex - 1) / 2; while(heap[parIndex] &gt; heap[childIndex]) { swap(heap[parIndex], heap[childIndex]); childIndex = parIndex; parIndex = (childIndex - 1) / 2; }
}
void _heappush_max(vector&lt;int&gt; &amp;heap, int val) { heap.push_back(val); int N = heap.size(); int childIndex = N - 1, parIndex = (childIndex - 1) / 2; while(heap[parIndex] &lt; heap[childIndex]) { // This is the only difference. swap(heap[parIndex], heap[childIndex]); childIndex = parIndex; parIndex = (childIndex - 1) / 2; }
}
Takes O(log(N)) time.// Program to perform deletion in a heap represented as an array
#include&lt;bits/stdc++.h&gt;
using namespace std;
auto start = chrono::steady_clock::now();
int main(){ vector&lt;int&gt; heap = {60, 50, 40, 30, 20}; //!deletion can only be performed at the root ie 60 //=&gt; copy the value of the last node into root node heap.at(0) = heap.at(heap.size()-1); //=&gt; remove the last node heap.erase(heap.end()-1); //=&gt; place the root node into its correct position (TOP to BOTTOM) int parent = 0; int left_child = parent*2 + 1; //for 0 based indexing int right_child = parent*2 + 2; bool complete = false; while(!complete){ int temp = parent; left_child = parent*2 + 1; right_child = parent*2 + 2; if(left_child &lt; heap.size() and heap.at(parent) &lt; heap.at(left_child)){ parent = left_child; } if(right_child &lt; heap.size() and heap.at(parent) &lt; heap.at(right_child)){ parent = right_child; } if(parent == temp){ //swap not done complete = true; } else{ swap(heap.at(parent), heap.at(temp)); } } //print the array for(auto i: heap){ cout &lt;&lt; i &lt;&lt; " "; } auto end = chrono::steady_clock::now(); auto diff = end-start; cout &lt;&lt; "\nExecution Time: " &lt;&lt; chrono::duration&lt;double, milli&gt;(diff).count() &lt;&lt; "ms"; return 0;
}
//* Time and Space Complexities: O(log(n)) and O(1) respectively
Heapify is converting an array to a valid heap structure.
Takes O(N) average time.
Heapify is applied to a single element and it propels it to the right position in the heap. But when talking about heapify in modern programming we often mean building the heap from the array, means heapifying all the nodes that are required (leaf nodes are already heaps).// code for the heapify function with buildHeap
#include &lt;bits/stdc++.h&gt;
using namespace std;
void heapify(vector&lt;int&gt; &amp;v, int i)
{ // heap and the position to be heapified int lg = i; // index showing the largest value int left_child = 2 * i + 1; int right_child = 2 * i + 2; // recursive strategy if (left_child &lt; v.size() and v.at(lg) &lt; v.at(left_child)) { lg = left_child; } if (right_child &lt; v.size() and v.at(lg) &lt; v.at(right_child)) { lg = right_child; } if (lg != i) { swap(v.at(lg), v.at(i)); heapify(v, lg); }
}
//Function to build heap which calls heapify for each element necessary
void buildHeap(vector&lt;int&gt; &amp;v){ for(int i = v.size()/2 - 1 ; i &gt;= 0 ;i--){ //leaf nodes don't need to be heapified //since they are already heaps heapify(v, i); }
}
auto start = chrono::steady_clock::now();
int main()
{ vector&lt;int&gt; v = {20, 40, 10, 30, 50}; buildHeap(v); //print the result for(auto i: v){ cout&lt;&lt;i&lt;&lt;" "; } auto end = chrono::steady_clock::now(); auto diff = end - start; cout &lt;&lt; "\nExecution Time: " &lt;&lt; chrono::duration&lt;double, milli&gt;(diff).count() &lt;&lt; "ms"; return 0;
}
//* Time and Space Complexities:
//* 1) Heapify O(log(n)) and O(1)
//* 2) build heap O(n)
//* overall O(nlog(n))
Efficient sorting algorithm that works in O(Nlog(N)) average complexity and O(1) space.Simple logic, keep moving the first element of the max heap to the end and reheapifying the remaining array.// Heap sort is like insertion sort but instead of linearly finding the min max element
// it used heap data stucture to fetch the elements
#include &lt;bits/stdc++.h&gt;
using namespace std;
void heapify(vector&lt;int&gt; &amp;v, int size, int i) // Size because as elements get sorted one by one the pool decreases
{ // heap and the position to be heapified int lg = i; // index showing the largest value int left_child = 2 * i + 1; int right_child = 2 * i + 2; // recursive strategy if (left_child &lt; size and v.at(lg) &lt; v.at(left_child)) //reverse sort ke liye bas ye less than ko greater than kar sakte hai { lg = left_child; } if (right_child &lt; size and v.at(lg) &lt; v.at(right_child)) { lg = right_child; } if (lg != i) { swap(v.at(lg), v.at(i)); heapify(v, size, lg); }
}
// Function to build heap which calls heapify for each element necessary
void buildHeap(vector&lt;int&gt; &amp;v)
{ for (int i = v.size() / 2 - 1; i &gt;= 0; i--) { // leaf nodes don't need to be heapified // since they are already heaps heapify(v, v.size(), i); }
}
void heap_sort(vector&lt;int&gt; &amp;v)
{ // first build heap for the first time buildHeap(v); for (int i = v.size() - 1; i &gt; 0; i--) { // size loop for each iteration the size of unsorted part decreases // 1) get the root which is maximum for maxHeap and swap it to the end swap(v.at(0), v.at(i)); // i = n-1 so we dont need to track the end element i will serve both purpose //2) heapify the one element as it is now out of order, the result of which will be a maxHeap again heapify(v, i, 0); // vector size position }
}
auto start = chrono::steady_clock::now();
int main()
{ vector&lt;int&gt; v = {-4,0,7,4,9,-5,-1,0,-7,-1}; heap_sort(v); for(auto i: v){ cout&lt;&lt;i&lt;&lt;" "; } auto end = chrono::steady_clock::now(); auto diff = end - start; cout &lt;&lt; "\nExecution Time: " &lt;&lt; chrono::duration&lt;double, milli&gt;(diff).count() &lt;&lt; "ms"; return 0;
}
]]></description><link>heaps/heaps.html</link><guid isPermaLink="false">Heaps/Heaps.md</guid><pubDate>Wed, 02 Jul 2025 18:54:08 GMT</pubDate></item><item><title><![CDATA[Topological Sort]]></title><description><![CDATA[Topological sorting is a specific ordering of the vertices of a graph that ensures that if there is an edge from u to v, then in the toposort u comes before v. This is only possible for Directed Acyclic Graphs.
There are various methods to find the topological sorting.This is a famous algorithm, it is a variation of the standard BFS. This algorithm is based on indegrees of the vertices.
Standard BFS A vertex is popped from the queue only when all its neighbors have been pushed into the queue for visiting.
Kahn's Algorithm A vertex is popped from the queue only when its indegree becomes zero. Means all the nodes that had a directed edge to the current vertex have already been taken care of and put into the toposort. This is the intuition behind the algorithm.def kahn_toposort(adj): V = len(adj) # finding the indegrees indegrees = [0]*V for vertex in range(V): for nbr in adj[vertex]: indegrees[nbr] += 1 q = deque() toposort = [] for v, indegree in enumerate(indegrees): if indegree == 0: q.append(v) # kind of like a multi source bfs while q: curr = q.popleft() toposort.append(curr) for nbr in adj[curr]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: q.append(nbr) return toposort
vector&lt;int&gt; kahn_toposort(vector&lt;vector&lt;int&gt;&gt; &amp;adj){ int V = adj.size(); vector&lt;int&gt; indegrees(V); for(auto const &amp;vertex: adj){ for(auto const &amp;neighbor: vertex){ indegrees[neighbor]++; } } queue&lt;int&gt; q; vector&lt;int&gt; toposort; for(int vertex = 0; vertex &lt; V; ++vertex){ if(indegrees[vertex] == 0) q.push(vertex); } while(!q.empty()){ int curr = q.front(); q.pop(); toposort.push_back(curr); for(auto const &amp;neighbor: adj[curr]){ indegrees[neighbor]--; if(indegrees[neighbor] == 0) q.push(neighbor); } } return toposort;
}
The topological sort can also be found using DFS. How do you do it? just standard DFS but at the end of each call you just push the node that is done and dusted into the toposort. What we mean by done and dusted is that all the depths ahead of it have been searched meaning all the nodes that appear after it are already pushed into the toposort.
The keen eyed among the readers must have guessed that this seems the reverse of toposort. Yes it is reversed. So you have to reverse the list to get the toposort.def dfs_toposort(adj, vertex, vis, toposort): vis.add(vertex) for nbr in adj[vertex]: if nbr not in vis: dfs_toposort(adj, nbr, vis, toposort) toposort.append(vertex)
void dfs_toposort(vector&lt;vector&lt;int&gt;&gt; &amp;adj, int vertex, unordered_set&lt;int&gt; &amp;vis, stack&lt;int&gt; &amp;toposort){ // Notice the Stack vis.insert(vertex); for(auto const &amp;nbr: adj[vertex]){ if(vis.count(nbr) == 0) dfs_toposort(adj, nbr, vis, toposort); } toposort.push(vertex);
}
Points to consider while using DFS for toposort:
Make sure to reverse the toposort in the driver function.
Make sure to run the toposort for all connected components as BFS takes care of them because of the indegree calculations, DFS will not.
def dfs_toposort(adj, vertex, vis, toposort): vis.add(vertex) for nbr in adj[vertex]: if nbr not in vis: dfs_toposort(adj, nbr, vis, toposort) toposort.append(vertex) class Solution: def topoSort(self, V, adj): toposort = [] vis = set() for i in range(V): if i not in vis: dfs_toposort(adj, i, vis, toposort) return list(reversed(toposort))
cool point about python: reversed returns an iterator and does not modify the original list. Where as sorted returns the sorted list.]]></description><link>graphs/topological-sort.html</link><guid isPermaLink="false">Graphs/Topological Sort.md</guid><pubDate>Wed, 02 Jul 2025 18:54:08 GMT</pubDate></item><item><title><![CDATA[Shortest Path Problem]]></title><description><![CDATA[Another important domain in graph theory is the ability to find the shortest distance between a source vertex &amp; a destination vertex. There are a lot of path finding algorithms. Each one of them has their merits and demerits.<a href=".?query=tag:greedy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#greedy">#greedy</a> <a href=".?query=tag:bfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bfs">#bfs</a>
Finds the shortest path from source node to all other nodes.
Directed/undirected graph does not matter.
Does not work when the graphs have negative edges/negative weight cycles (more on this below #7).
Can use set/heap to reduce the time taken and number of calls than using a queue.
Time Complexity: O(ElogV) for adj list using heap. O(V^2) for adjacency matrix. In case you used queue instead of min heap, it jumps to O(V*E) due to suboptimal calls.
Space Complexity: O(V)
It is again a variation of BFS, instead of using a visited array we rely on the logic that when we try to revisit an already visited thing (The main purpose of having the visited array in the first place). If we have a positive weight the distance is never going to decrease so we are not going to repush stuff into the queue. This is why Dijkstra's algorithm fails for negative loop cycles because it keeps revolving at the loop. If there are no negative cycles but a negative edge, like for a directed graph it still can produce incorrect answers due to negative edges and have unnecessary extra calls.
Drawing 2023-08-26 13.15.15.excalidraw<br><img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;"> Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. <img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;">8 8 s 0 0 even though s is in adj of d we cannot repush it
into the graph because 8 + 8 is not less than 0 d I do not like writing algorithms, I think the algorithms are best defined by the code. So here is the code for the Dijkstra's algorithm.def dijkstra(adj, S): q = [(0, S)] heapq.heapify(q) dist = [float('inf') for _ in range(V)] dist[S] = 0 while q: distance, curr = heapq.heappop(q) for nbr, wt in adj[curr]: if distance + wt &lt; dist[nbr]: dist[nbr] = distance + wt # distance and dist[curr] are the same thing and they represent current shortest known path to curr heapq.heappush(q, (dist[nbr], nbr)) # Push the updated distance to the queue when you see a new known shortest path return [i if i != float('inf') else -1 for i in dist]
vector&lt;int&gt; dijkstra(vector&lt;vector&lt;int&gt;&gt; &amp;adj, int S){ int V = adj.size(); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt; pq; pq.push({0, S}); vector&lt;int&gt; dist(V, INT_MAX); dist[S] = 0; while(!q.empty()){ auto [distance, curr] = pq.front(); pq.pop(); for(auto nbr_wt: adj[curr]){ int nbr = nbr_wt[0], wt = nbr_wt[1]; if(distance + wt &lt; dist[nbr]){ dist[nbr] = distance + wt; pq.push({dist[nbr], nbr}); } } } return distance; // Make sure to replace INT_MAX if asked in the problem
}
You may also require to print or fetch the actual shortest path, instead of the distances. This can also be done using Dijkstra's algorithm. Store the previous elements to each element in a prev array and then traverse it to find the distances.def dijkstra_path(adj, S): V = len(adj) q = [(0, S)] heapq.heapify(q) dist = [float('inf')]*V; dist[S] = 0 prev = [-1]*V while q: distance, curr = heapq.heappop(q) for nbr, wt in adj[curr]: if distance + wt &lt; dist[nbr]: dist[nbr] = distance + wt prev[nbr] = curr heapq.heappush(q, (dist[nbr], nbr)) return (dist, prev)
Now suppose you need to find the shortest path from vertex 0 to vertex 6. So first push 6 into a stack, then go to prev[6] and push it into the stack and then go to prev of this prev, do this until you reach source.<br><a href=".?query=tag:dp" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dp">#dp</a> <a href=".?query=tag:bfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bfs">#bfs</a>
This is another path finding algorithm, this however works in case of negative edges unlike Dijkstra. In case of negative cycles too, this can be used to find the presence of such cycles. Source to all nodes.
Can be applied on any graph, be it directed or undirected. Undirected weighted graph can be treated like a directed graph, with 2 arrows with same weight coming into and going out from the nodes.
Time Complexity: O(V*E)
Space Complexity: O(E)
The time complexity is worse than Dijkstra.Note: There is no notion of shortest path in case of negative cycles, cause if you start from a node and come back to the same node and your net cost is smaller then you will keep on revolving on the cycle. So we only detect the presence of such cycles.How does it work?
For a graph with V vertices, you need to relax each edge V - 1 times.
The Bellman Ford Algorithm just estimates the distances of all nodes from the source node and then updates the distances as more and more shorter ways are discovered.In first iteration, the immediate neighbors of the source are relaxed. In second iteration neighbors of these neighbors are relaxed, In BFS in this step the previous neighbors have been kicked out of the queue, but Bellman ford does it for all the nodes thereby ensuring a shortest path.
Why V - 1 iterations. For any graph with V vertices, you need at most V-1 traversals through all edges to relax them into shortest distances. Due to fixed amount of iterations, we do not need to worry about infinite cycles.Detecting Negative Weight Cycles
After you are done calculating the loop V - 1 times, rerun the loop again, if the distances still reduce for atleast one vertex, that means there is a negative cycle present.Why V - 1 iterations?
That seems like such a random number like tennis scoreboards. But it is not consider a graph with v vertices. Lets take the source node s. Let me ask you this, what is the maximum number of ways that can come out of this source to visit all other nodes? It is V - 1 see the diagram below.Drawing 2023-08-26 16.50.59.excalidraw
Since you are going through every edge V - 1 times, it is guaranteed that from any node to any other node (at max V - 1 things can come out) the edges will be covered in the loops.def bellman_ford(adj, S, check_neg): V = len(adj) dist = [float('inf')]*V dist[S] = 0 for i in range(V-1): # traversing each edge for vertex, nbrs in enumerate(adj): for nbr, wt in nbrs: # relaxing the edges if needed if dist[vertex] + wt &lt; dist[nbr]: dist[nbr] = dist[vertex] + wt neg_cycles = False if check_neg: for vertex, nbrs in enumerate(adj): for nbr, wt in nbrs: if dist[vertex] + wt &lt; dist[nbr]: neg_cycles = True break return (dist, neg_cycles) if check_neg else dist
pair&lt;vector&lt;int&gt;, bool&gt; bellman_ford(vector&lt;vector&lt;int&gt;&gt; &amp;adj, int S){ int V = adj.size(); bool neg_cycles = false; vector&lt;int&gt; dist(V, INT_MAX); dist[S] = 0; for(int i = 0; i &lt; V; i++){ // Traversing the edges for(int u = 0; u &lt; V; u++){ for(auto const &amp;[v, w]: adj[u]){ // Relaxing the edges if(dist[u] + w &lt; dist[v]){ dist[v] = dist[u] + w; if i == V: neg_cycles = true; } } } } return make_pair(dist, neg_cycles);
} This only works for unweighted graphs. We assume the weights to be 1.
Used for source to single destination.
Why do we even use this? This is slightly faster than the Dijkstra's algorithm for this particular graph.
Time Complexity: O(V + E)
Space Complexity: O(V)
<br>This is used in problems where you need to fetch the actual shortest path between two nodes. <a data-href="Snakes &amp; Ladders" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Snakes &amp; Ladders</a>def BFS(adj, src, dest, v, pred, dist): # a queue to maintain queue of vertices whose # adjacency list is to be scanned as per normal # DFS algorithm queue = [] # boolean array visited[] which stores the # information whether ith vertex is reached # at least once in the Breadth first search visited = [False for i in range(v)]; # initially all vertices are unvisited # so v[i] for all i is false # and as no path is yet constructed # dist[i] for all i set to infinity for i in range(v): dist[i] = 1000000 pred[i] = -1; # now source is first to be visited and # distance from source to itself should be 0 visited[src] = True; dist[src] = 0; queue.append(src); # standard BFS algorithm while (len(queue) != 0): u = queue[0]; queue.pop(0); for i in range(len(adj[u])): if (visited[adj[u][i]] == False): visited[adj[u][i]] = True; dist[adj[u][i]] = dist[u] + 1; pred[adj[u][i]] = u; queue.append(adj[u][i]); # We stop BFS when we find # destination. if (adj[u][i] == dest): return True; return False;
I have no clue why this exists and is important. <br><a href=".?query=tag:dp" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dp">#dp</a>
This is a multi source shortest path finding algorithm. From every node to every other node.
Works for negative edges and cycles as well.
Time Complexity: O()
Space Complexity: O()
How does it work:
Require adjacency matrix for implementing this algorithm.
You go from every node to . You either go through directly or try to go through some other intermediate node . Now it is not guaranteed that you will reach the destination (may have distance). You keep doing this for all nodes over and over. Choose each node as intermediate node and for each iteration, try to go directly to the node A to B and try to go from that chosen intermediate node. And minimize the distance
A[i][j] = min(A[i][j], A[i][x] + A[x][j])
Once you are done with choosing all the nodes as intermediate node, the final matrix will give you shortest distance from every node to every other node.
def floyd_warshall(adj, check_neg): V = len(adj) cost_matrix = [[i if i != -1 else float('inf') for i in row] for row in adj] for x in range(V): for i in range(V): for j in range(V): cost_matrix[i][j] = min(cost_matrix[i][j], cost_matrix[i][x] + cost_matrix[x][j]) neg_cycle = False if check_neg: for i in range(V): if cost_matrix[i][i] &lt; 0: neg_cycle = True break return cost_matrix if not check_neg else (cost_matrix, neg_cycle)
<br>Silly little goose <img class="emoji is-unresolved" draggable="false" alt="ðŸ¦†" src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f986.svg" height="14px" target="_self" style="max-width: 100%;"> tip about python. When you pass a list to a function, you are essentially passing a reference to the list object (since everything is a object in python). You can modify the contents and it will reflect in the original object, but once you reassign the thing, you are reassigning the pointer to a new object. IT IS NOT GOING TO REFLECT IN THE ORIGINAL OBJECT, THE LINK IS JUST LOST.pair&lt;vector&lt;vector&lt;int&gt;&gt;, bool&gt; floyd_warshall(vector&lt;vector&lt;int&gt;&gt; adj, bool check_neg){ int V = adj.size(); vector&lt;vector&lt;int&gt;&gt; cost_matrix(adj); for(int i = 0; i &lt; V; i++){ for(int j = 0; j &lt; V; j++) if(adj[i][j] == -1) cost_matrix[i][j] = INT_MAX; } for(int x = 0; x &lt; V; x++){ for(int i = 0; i &lt; V; i++){ for(int j = 0; j &lt; V; j++){ if(cost_matrix[i][x] != INT_MAX and cost_matrix[x][j] != INT_MAX){ cost_matrix[i][j] = min(cost_matrix[i][j], cost_matrix[i][x] + cost_matrix[x][j]); } } } } neg_cycle = false; for(int i = 0; i &lt; V; i++){ if(cost_matrix[i][i] &lt; 0){ neg_cycle = 0; break; } } return make_pair(cost_matrix, neg_cycle);
}
This is an extension of Dijkstra's algorithm It is used in many real world applications.
Dijkstra is a greedy algorithm so it can only looks for the current visible shortest path. This can still not be fastest since in cases there may be an overall shortest route which may appear to be far at first. A* introduces a heuristic which tells the algorithm that tells the algorithm that it is getting close. So instead of using the greedy distance for ordering the priority queue or the set, we use this heuristic distance. It is an estimated distance however so it cannot be taken into account for actual calculation, it is just for producing a current that propels the algorithm to converge faster.
Drawing 2023-08-26 21.55.35.excalidraw
As you can see in the above diagram, Dijkstra will push the nodes x and y, but the priority queue will put the 3 weighted node first, this will create unnecessary calls. Because we will move on in the path of y and visit the nodes p, q and r, but later on their distances are reupdated from the path of x. If we had an approximate distance called heuristic. We could have introduced a bias in the algorithm for picking better paths. There can be various heuristics like manhatten distance, euclidian distance etc. A* may not produce shortest paths always, it heavily depends on correct modelling of the heuristics.The code will not be provided here, as it is not useful in problem solving on platforms.]]></description><link>graphs/shortest-path-problem.html</link><guid isPermaLink="false">Graphs/Shortest Path Problem.md</guid><pubDate>Wed, 02 Jul 2025 18:53:29 GMT</pubDate><enclosure url="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Representation of Graphs]]></title><description><![CDATA[Representation of graphs is done in a number of waysOne way of representing a graph with V vertices is using a V*V matrix. Whenever there is an edge between two vertices u and v then Adj[u][v] != 0. The rest stuff is zero where there are no edges. It can represent all types of graphs weighted unweighted, cyclic etc. Demerit: Wastage of space because when there is no edge but still we are consuming memory to store the zero.<img alt="Pasted image 20230821102028.png" src="_assets/pasted-image-20230821102028.png" target="_self">This is the most commonly used and most efficient one to represent graphs. We make a map of the vertex to a list that has all the nodes such that there exists an edge between u and .<br><img alt="Pasted image 20230821102417.png" src="_assets/pasted-image-20230821102417.png" target="_self">To represent a weighted graph we can just use a pair/tuple of (node/weight) in the list.Below are the code snippets.template &lt;typename Container&gt;
unordered_map&lt;int, vector&lt;int&gt;&gt; build_graph(const Container &amp;edges, bool directed = false)
{ unordered_map&lt;int, vector&lt;int&gt;&gt; adj; for (const auto &amp;edge : edges) { int u, v; if constexpr (std::is_same_v&lt;Container, vector&lt;vector&lt;int&gt;&gt;&gt;) { u = edge[0]; v = edge[1]; } else if constexpr (std::is_same_v&lt;Container, vector&lt;pair&lt;int, int&gt;&gt;&gt;) { u = edge.first; v = edge.second; } adj[u].push_back(v); if (!directed) adj[v].push_back(u); } return adj;
}
def build_graph(edges, directed): adj = defaultdict(list) weighted = len(edges[0]) == 3 for edge in edges: if weighted: u,v,w = edge adj[u].append(v, w) if not directed: adj[v].append(u, w) else: u,v = edge adj[u].append(v) if not directed: adj[v].append(u) return adj
Note: The python code works for weighted graphs too.This is one more way of representing graphs, basically it is a list of tuples where each tuple represents an edge between u and v or from u to v in case of directed graphs. some times there are weights associated too.In this form the graph is implied. A lot of problems are formed using this method. You are given a matrix which has some zeroes and ones, you need to do DFS or BFS on them. The neighbors of the cell are 4 connected or 8 connected. generally 4 connected you need to find the neighbors of the cells and then apply traversal. Below is the snippet for the valid neighbors.vector&lt;pair&lt;int, int&gt;&gt; valid_neighbors(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;graph){ vector&lt;pair&lt;int, int&gt;&gt; neighbors, delta{{{0,-1}, {-1, 0}, {0, 1}, {1, 0}}}; int m = graph.size(), n = graph[0].size(); for(auto const &amp;[dx, dy]: delta){ int r = x + dx, c = y + dy; if(r &gt;=0 and r &lt; m and c &gt;= 0 and c &lt; n) neighbors.push_back({r,c}); } return neighbors;
}
def valid_neighbors(x, y, graph): m, n = len(graph), len(graph[0]) delta = [(-1,0),(0,-1),(0,1),(1,0)] neighbors = [] for dx,dy in delta: r, c = x + dx, y + dy if 0&lt;=r&lt;m and 0&lt;=c&lt;n: neighbors.append((r,c)) return neighbors
]]></description><link>graphs/representation-of-graphs.html</link><guid isPermaLink="false">Graphs/Representation of Graphs.md</guid><pubDate>Wed, 02 Jul 2025 18:53:28 GMT</pubDate><enclosure url="_assets/pasted-image-20230821102028.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="_assets/pasted-image-20230821102028.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Problems]]></title><description><![CDATA[<a data-href="Flood fill algorithm" href="problems/gfg/flood-fill-algorithm.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Flood fill algorithm</a><br>
<a data-href="Is Graph Bipartite" href="problems/leetcode/is-graph-bipartite.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Is Graph Bipartite</a><br>
<a data-href="Alien Dictionary" href="problems/gfg/alien-dictionary.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Alien Dictionary</a>]]></description><link>graphs/problems.html</link><guid isPermaLink="false">Graphs/Problems.md</guid><pubDate>Wed, 02 Jul 2025 18:53:27 GMT</pubDate></item><item><title><![CDATA[Minimum Spanning Trees (MST)]]></title><description><![CDATA[What is a spanning tree?For an connected &amp; undirected graph, a spanning tree is a subgraph of the graph that is also a tree and connects all nodes together.For a graph with V vertices, a spanning tree will have exactly V - 1 edges.Minimum Spanning Tree: It is defined for a weighted undirected graph &amp; is a spanning tree which has the minimum possible weights of the edges. So if there are 2 edges from node u to v then the edge with smaller weight will be chosen to keep them connected.There are various algorithms for finding the Minimum Spanning Trees.Cuz its a tree, it can't have cycles duh!Properties of MST
If each edge weight is unique then there can be only one MST.
For every cycle in the graph, the edge with the largest weight in the cycle, cannot belong to any MST.
For a Cut C of a <a data-href="Graphs" href="graphs/graphs.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graphs</a> any edge E that belongs to the cut set of C that has the least weight out of all the edges of the cut set, belongs to all the edges of the cut set.
<br><img alt="example1-1.webp" src="_assets/example1-1.webp" target="_self" style="width: 500px; max-width: 100%;"><img alt="example2-1.webp" src="_assets/example2-1.webp" target="_self" style="width: 500px; max-width: 100%;">
There are various algorithms for finding the minimum spanning trees.<br><a href=".?query=tag:greedy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#greedy">#greedy</a> Intuition Behind the Prim's Algorithm:
The cut property of MST is the intuition behind the algorithm. Consider the below graph:
Drawing 2023-08-29 11.13.50.excalidrawIt is a valid cut because it breaks the graph into two disjoint set of vertices. There are 2 edges in the cut-set of this cut. Edge with weight 1 and the edge with weight 5. Now according to the cut property, 1 has to be the part of the MST, we are not sure about 5, maybe its a part maybe its not. But we got one surity to we push that into the MST. We keep doing this for all the nodes and get the edges that are sure. When all the vertices are checked then we have the final MST.
In the case of this graph, below are the steps:
Drawing 2023-08-29 11.23.21.excalidraw
In the above steps, the edge with weight 5 is the only one that was not confirmed to be a part of the MST, so it is not the part of the MST.So the algorithm is making cuts, keeping the track of the cut-set and choosing the minimum every time. We utilize a priority queue for this task. vis means the node has become the part of the MST.
Time Complexity: Elog(E)
Space Complexity: O(E)def prims_mst(adj): V = len(adj) vis = set() mst = [] # contains the edges u,v that are part of the MST pq = [(0, 0, -1)] # (weight, node, parent) mst_wt = 0 while pq: wt, curr, par = heapq.heappop(pq) if curr not in vis: # PITFALL, pq may have already visited nodes because we have to revisit nodes like above diagram, more than once to make sure that they get 0 tick marks for nbr, w in adj[curr]: heapq.heappush(pq, (w, nbr, curr)) # not adding the nbr to visited here vis.add(curr) # because of the PITFALL we have to keep it here. if par != -1: mst_wt += wt mst.append((par, curr)) return (mst_wt, mst)
struct Edge { int weight; int node; int parent; Edge(int w, int n, int p) : weight(w), node(n), parent(p) {} bool operator&gt;(const Edge&amp; other) const { return weight &gt; other.weight; }
}; typedef vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; AdjList; // List of (node, weight) pairs pair&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; primsMST(const AdjList&amp; adj) { int V = adj.size(); set&lt;int&gt; vis; vector&lt;pair&lt;int, int&gt;&gt; mst; // contains the edges (u, v) that are part of the MST priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt;&gt; pq; int mst_wt = 0; pq.push(Edge(0, 0, -1)); while (!pq.empty()) { Edge e = pq.top(); pq.pop(); if (vis.find(e.node) == vis.end()) { for (const auto&amp; neighbor : adj[e.node]) { pq.push(Edge(neighbor.second, neighbor.first, e.node)); } vis.insert(e.node); if (e.parent != -1) { mst_wt += e.weight; mst.push_back(make_pair(e.parent, e.node)); } } } return make_pair(mst_wt, mst);
}
<br>This is where we introduce the concept of <a data-href="Disjoint Set Union(DSU)" href="graphs/disjoint-set-union(dsu).html#_0" class="internal-link" target="_self" rel="noopener nofollow">Disjoint Set Union(DSU)</a> to you, go ahead and read that and come back &amp; this algorithm will be a breeze.Intuition behind Kruskal's Algorithm
This is much more intuitive, because unlike prims algorithm you do not need to know any properties. So let us ask ourselves what is the MST?
Tree with V vertices and V - 1 edges that has the minimum weight. Every edge is crucial in the MST and we do not need extra edges that serve no purpose.There it is, we take the smallest weight edges one by one and do a union of those, if the nodes of the edge already belong to the same component means that there is already a minimum path that lighter edge have made between the two nodes in discussion, so we do not need this extra edge.<br>Now that you have done that <img class="emoji is-unresolved" draggable="false" alt="ðŸ˜Š" src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f60a.svg" height="14px" target="_self" style="max-width: 100%;"> let's move too the Kruskal's algorithm.# import DSU class here
def kruskals_mst(adj): V = len(adj) ds = DSU(V) # initialize the Disjoint Set mst, mst_wt = [], 0 # Constucting a sorted edge list pq = [] vis = set() for i in range(V): for nbr, wt in adj[i]: if (nbr, i) not in vis: pq.append((wt, i, nbr)) vis.add((i, nbr)) heapq.heapify(pq) # you can also just reverse sort and use pop # perform union find to get MST while pq: w, u, v = heapq.heappop(pq) if ds.find(u) != ds.find(v): ds.union(u, v) mst_wt += w mst.append((u, v)) if len(mst) == V - 1: break return (mst_wt, mst)
]]></description><link>graphs/minimum-spanning-trees-(mst).html</link><guid isPermaLink="false">Graphs/Minimum Spanning Trees (MST).md</guid><pubDate>Wed, 02 Jul 2025 18:53:27 GMT</pubDate><enclosure url="_assets/example1-1.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="_assets/example1-1.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Graphs]]></title><description><![CDATA[Graphs are data structures made up of vertices and edges. Below is a simple undirected graph with some vertices and edges connecting them.Drawing 2023-08-21 09.39.36.excalidraw<img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;"> Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. <img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;">Some real life applications of graphs: Google Maps
Social networking sites to map the user data and build connections between users
Circuit Design, the electrical elements can be treated as nodes and the electrical connections as edges.
<br>HTML and React DOM which are an <a data-href="N-ary" href=".html" class="internal-link" target="_self" rel="noopener nofollow">N-ary</a> tree or graphs.
Paint Bucket Tool
Packet switching in CCN.
Sequence of nodes from one node to another passing through edges.<br><img alt="Pasted image 20230821095302.png" src="_assets/pasted-image-20230821095302.png" target="_self">A closed path is when the initial node is same as the final node. A closed path means there is a cycle.A cycle is a closed path in which no two nodes are repeating except the first and the last node.<br><img alt="Pasted image 20230821095820.png" src="_assets/pasted-image-20230821095820.png" target="_self">In a connected component there is a path between every 2 nodes or simply that there are no isolated nodes.
A graph may comprise more that one connected componentsDrawing 2023-08-21 10.01.13.excalidrawThis is the infamous mesh topology. Every node is connected to every other node.<br>The edges are not directional. The nodes appear on each other's <a data-href="adjacency lists" href=".html" class="internal-link" target="_self" rel="noopener nofollow">adjacency lists</a>. The edges are directional, we say "There is an edge from node A to node B".The edges have some weights associated with them.This type of graph does not contain cycles.Bipartite graph is a special type of graph whose vertices can be divided into 2 independent sets U and V such that every node in U has an edge connecting to a node in V.
Definition on color: Start with 2 colors and keep painting nodes with alternating colors, no two connected ones should have same color, if you can do that with just 2 colors, your graph is bipartite.<br><img alt="Pasted image 20230821101105.png" src="_assets/pasted-image-20230821101105.png" target="_self">A sparse graph is a graph in which there are not many edges between the nodes, In such types of graphs the adj matrix representation wastes a lot of space.
A dense graph is a graph in which there are large number of edges between the nodes. The adj matrix is suitable here, because of less number of zeros.<br>Dense graph&nbsp;is a graph in which the number of edges is close to the maximal number of edges.&nbsp;Sparse graph&nbsp;is a graph in which the number of edges is close to the minimal number of edges.&nbsp;Sparse graph&nbsp;can be a&nbsp;<a data-tooltip-position="top" aria-label="http://mathworld.wolfram.com/DisconnectedGraph.html" rel="noopener nofollow" class="external-link is-unresolved" href="http://mathworld.wolfram.com/DisconnectedGraph.html" target="_self"><em></em></a>disconnected graph.In a graph, the maximal number of edges refers to the total number of edges that a graph can have if all possible edges between distinct vertices are present. This value depends on the number of vertices in the graph. For an undirected graph with V vertices, the maximal number of edges is given by the formula:Maximal Edges = V * (V - 1) / 2The minimal number of edges in a graph depends on its structure. For an undirected graph, the minimal number of edges occurs in the case of a disconnected graph. In a disconnected graph, the graph is composed of two or more separate components that have no edges between them. The minimal number of edges in such a graph would be 0, as there are no connections between the components.There are two types of degrees in a directed graph, if there is an edge coming toward a vertex then it counts as indegree 1 for that node. Similarly there is outdegree.A cut is a partition of a graph vertices into two disjoint subsets.
A&nbsp;cut&nbsp;C&nbsp;= (S,T)&nbsp;is a partition of&nbsp;V&nbsp;of a graph&nbsp;G&nbsp;= (V,E)&nbsp;into two subsets&nbsp;S&nbsp;and&nbsp;T. The&nbsp;cut-set&nbsp;of a cut&nbsp;C&nbsp;= (S,T)&nbsp;is the set&nbsp;{(u,v) âˆˆ&nbsp;E&nbsp;|&nbsp;u&nbsp;âˆˆ&nbsp;S,&nbsp;v&nbsp;âˆˆ&nbsp;T} i.e. both the pair has one node in S and the other node of the pair in T.Minimum &amp; Maximum Cut: Minimum possible cut in the graph(cuts least amount of edges), maximum is maximum possible cut (cuts largest number of Edges)Drawing 2023-08-27 14.11.51.excalidraw]]></description><link>graphs/graphs.html</link><guid isPermaLink="false">Graphs/Graphs.md</guid><pubDate>Wed, 02 Jul 2025 18:53:27 GMT</pubDate><enclosure url="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Disjoint Set Union(DSU)]]></title><description><![CDATA[A special data structure that is used to tell whether a vertex v belongs to a connected component or not. Traditionally you would use DFS or BFS to traverse the component and try to find v, but Disjoint sets can do this in O(1) time with respect to the DS.Time Complexity: Ackermann's FunctionA disjoint set data structure had 2 methods union &amp; find. Union merges a vertex to the connected component of another vertex and does nothing if they belonged to the same component. Find tells the ultimate parent of the the nodes, if they are same they belong to the same component.
Drawing 2023-08-29 13.29.34.excalidraw<img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;"> Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. <img class="emoji is-unresolved" draggable="false" alt="âš " src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" height="14px" target="_self" style="max-width: 100%;">before merge After merge Take a look at the above graph, instead of joining the elements to their immediate parent in union operation, we do it to an ultimate parent of the whole component, the find function does the job of finding this ultimate parent.
Union by rank: We calculate the union by a rank, the node with higher rank is assigned as the parent.
Union by size: We calculate union by the number of nodes in a component. The vertex with larger component is assigned as the parent.
What is rank?
Rank is the estimate of the depth of the tree. Union by rank is an optimization technique of the union operation, in which we try to reduce the depth of the tree by merging the nodes according to rank.class DSU: parent = None rank = None def __init__(self, n): self.parent = [i for i in range(n)] self.rank = [0] * n def union(self, u, v): u, v = self.find(u), self.find(v) # find the ultimate parents if u != v: if self.rank[u] &gt;= self.rank[v]: self.parent[v] = u else: self.parent[u] = v self.rank[u] += self.rank[v] == self.rank[u] # increases only when an equivalent forest is added, like the 2048 game. return True # do not belong to the same component, union did happen return False # belong to the same component and union did not happen def find(self, v): if self.parent[v] == v: return v self.parent[v] = self.find(self.parent[v]) # path compression happens here return self.parent[v]
class DSU { vector&lt;int&gt; parent, rank; DSU(int n){ parent.resize(n); iota(parent.begin(), parent.end(), 0); rank.resize(n); } int find(int u){ if(parent[u] == u) return u; return parent[u] = find(parent[u]); } bool union(int u, int v){ int u_root = find(u), v_root = find(v); if(u_root != v_root){ if(rank[u_root] &gt;= rank[v_root]) parent[v_root] = u_root; else parent[u_root] = v_root; rank[u_root] += rank[u_root] == rank[v_roo]; return true; } return false; }
};
Why does rank only increase when the ranks are same?
Drawing 2023-08-29 18.39.55.excalidraw
Reason for attaching smaller to larger and not reverse. Because we do not want to increase the height of the tree which which increase our lookup time.Why path compression?
It is another optimization technique that is used to speed up the disjoint set. It effectively reduces the height of the tree to an at max 2 in log(N) time complexity.class DSU: parent = None size = None def __init__(self, n): self.parent = [i for i in range(n)] self.size = [1]*n def union(self, u, v): u_root, v_root = self.find(u), self.find(v) if u_root != v_root: if self.size[u_root] &gt;= self.size[v_root]: self.size[u_root] += self.size[v_root] self.parent[v_root] = u_root else: self.size[v_root] += self.size[u_root] self.parent[u_root] = v_root return True return False def find(self, u): if self.parent[u] == u: return u self.parent[u] = self.find(self.parent[u]) return self.parent[u]
]]></description><link>graphs/disjoint-set-union(dsu).html</link><guid isPermaLink="false">Graphs/Disjoint Set Union(DSU).md</guid><pubDate>Wed, 02 Jul 2025 18:53:26 GMT</pubDate><enclosure url="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/26a0.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Depth First Search (DFS)]]></title><description><![CDATA[This is a traversal technique of graphs, which goes depth-wise. It will go from a node to one of its neighbors and then go into one of the neighbors' neighbors and then backtracks when it cant go deeper.It utilizes stack for the order of nodes. The recursive implementation is the most common as it is way shorter than both BFSes and the iterative DFS.
Time and Space Complexity: O(V) each node is visited only once and the recursion stack takes space for each step.# Snippet created by sameer 21-08-2023
def dfs(adj, vertex, vis): vis.add(vertex) for neighbor in adj[vertex]: if not vis[neighbor]: dfs(adj, neighbor, vis)
// Snippet created by sameer 21-08-2023
void dfs(const unordered_map&lt;int, vector&lt;int&gt;&gt;&amp; adj, int vertex, unordered_set&lt;int&gt;&amp; vis) { vis.insert(vertex); for (int neighbor : adj[vertex]) { if (vis.find(neighbor) == vis.end()) { dfs(adj, neighbor, vis); } }
}
# Snippet created by sameer 21-08-2023
def valid_neighbors(x, y, graph): m, n = len(graph), len(graph[0]) delta = [(-1,0),(0,-1),(0,1),(1,0)] neighbors = [] for dx,dy in delta: r, c = x + dx, y + dy if 0&lt;=r&lt;m and 0&lt;=c&lt;n: neighbors.append((r,c)) return neighbors
def dfs_impl(matrix, vertex, vis): x, y = vertex vis.add(vertex) for r, c in valid_neighbors(x, y, matrix): if (r, c) not in vis: dfs_impl(matrix, (r, c), vis)
// Snippet created by sameer 21-08-2023
vector&lt;pair&lt;int, int&gt;&gt; valid_neighbors(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;graph){ vector&lt;pair&lt;int, int&gt;&gt; neighbors, delta{{{0,-1}, {-1, 0}, {0, 1}, {1, 0}}}; int m = graph.size(), n = graph[0].size(); for(auto const &amp;[dx, dy]: delta){ int r = x + dx, c = y + dy; if(r &gt;=0 and r &lt; m and c &gt;= 0 and c &lt; n) neighbors.push_back({r,c}); } return neighbors;
}
void dfs_impl(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, pair&lt;int, int&gt; vertex, vector&lt;vector&lt;int&gt;&gt; vis){ auto [x, y] = vertex; vis[x][y] = true; for(auto [r, c]: valid_neighbors(x, y, matrix)){ if(!vis[r][c]) dfs_impl(matrix, {r, c}, vis); }
}
def dfs_iter(adj, vertex, vis): stack = [] stack.append(vertex) vis.add(vertex) while stack: node = stack.pop() for neighbor in adj[node]: if neighbor not in vis: vis.add(neighbor) stack.append(neighbor)
]]></description><link>graphs/depth-first-search-(dfs).html</link><guid isPermaLink="false">Graphs/Depth First Search (DFS).md</guid><pubDate>Wed, 02 Jul 2025 18:53:26 GMT</pubDate></item><item><title><![CDATA[Cycle Detection]]></title><description><![CDATA[Read <a data-href="Graphs" href="graphs/graphs.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graphs</a> to know more about cycles. Below are the variants of this problem.<br>Cycle detection in undirected graphs follows one simple logic you get a free pass if you are my parent. Means when I am revisiting the vertex I have visited earlier, I can only continue if it is my parent or halt. Be it <a data-href="Breadth First Search (BFS)" href="graphs/breadth-first-search-(bfs).html#_0" class="internal-link" target="_self" rel="noopener nofollow">Breadth First Search (BFS)</a> or <a data-href="Depth First Search (DFS)" href="graphs/depth-first-search-(dfs).html#_0" class="internal-link" target="_self" rel="noopener nofollow">Depth First Search (DFS)</a> in both of the algorithms you have to keep track of the parent of the current node.Below is the code snippet which is self-explanatory.
Note: You will have to run the code for each connected component with a loop if it's not visited.def undir_cycle_bfs(adj, vertex, vis): parent = {vertex: -1} q = deque() q.append(vertex) vis.add(vertex) while q: curr = q.popleft() for nbr in adj[curr]: if nbr not in vis: vis.add(nbr) parent[nbr] = curr q.append(nbr) elif nbr != parent[curr]: return True # cycle is present return False
Note: do not get confused by why we are setting the parent of the source node as -1. Because it's visited first so we have to do all operations there itself and as long as the vertexes are positive, it works always even for self edges dry run.bool undir_cycle_bfs(vector&lt;vector&lt;int&gt;&gt; &amp;adj, int vertex, unordered_set&lt;int&gt; &amp;vis){ unordered_map&lt;int, int&gt; parent({vertex, -1}); queue&lt;int&gt; q; q.append(vertex); vis.insert(vertex); while(!q.empty()){ int curr = q.pop(); for(auto const &amp;nbr: adj[curr]){ if(vis.count(nbr) == 0){ vis.insert(nbr); parent[nbr] = curr; q.push(nbr); } else if (nbr != parent[curr]): return true; } } return false;
}
The approach is similar again, here also we keep track of the parent vertex for each vertex.
Before the call starts in the driver you have to manually set the parent of source to -1.def undir_cycle_dfs(adj, vertex, vis, parent): vis.add(vertex) for nbr in adj[vertex]: if nbr not in vis: parent[nbr] = vertex if undir_cycle_dfs(adj, nbr, vis, parent): return True elif nbr != parent[vertex]: return True return False
bool undir_cycle_dfs(vector&lt;vector&lt;int&gt;&gt; &amp;adj, unordered_set&lt;int&gt; &amp;vis, unordered_map&lt;int, int&gt; &amp;parent){ vis.insert(vertex); for(auto const &amp;nbr: adj[vertex]){ if(vis.count(nbr) == 0){ parent[nbr] = vertex; if(undir_cycle_dfs(adj, nbr, vis, parent)) return true; } else if(nbr != parent[vertex]) return true; } return false;
}
So our parent logic will fail here, see the below diagramabsBFS failing: In this case if we start from the vertex s BFS will first visit a and b then when is the turn of a, a sees that b is already visited but it is not my parent so a call will return true. But infact there is no cycle here.
DFS failing: In this case if we start from the vertex s DFS will first visit a, then visit b from a's call. Then returns. Then continues in the adj of s for the next branch. It sees that b is already visited but it is not the parent of curr vertex s so it returns true, but infact there is no cycle in this graph.<br>This can be done using the property of <a data-href="Topological Sort" href="graphs/topological-sort.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Topological Sort</a>. Which is that a valid toposort can only be found for a directed acyclic graph.
So try to find the toposort of the graph and if the number of vertices in toposort &lt; number vertices in the graph =&gt; cycle is present.
Below is the implementation given for the Kahn toposort.def kahn_toposort(adj): V = len(adj) # finding the indegrees indegrees = [0]*V for vertex in range(V): for nbr in adj[vertex]: indegrees[nbr] += 1 q = deque() toposort = [] for v, indegree in enumerate(indegrees): if indegree == 0: q.append(v) # kind of like a multi source bfs while q: curr = q.popleft() toposort.append(curr) for nbr in adj[curr]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: q.append(nbr) return toposort
def check_cycle(adj): return len(adj) == len(kahn_toposort(adj))
It can be done using DFS alone without the use of topological sorting. First of all we need to understand the nature of the cycles in Directed Graphs.Let's assume we are doing a DFS traversal of a directed graph. We can say that there is a cycle in the graph if we visit a node that has already been visited in the current depth line.
See the diagram below-Drawing 2023-08-26 01.48.03.excalidraw
Suppose the orange depth line is visited first by the DFS, it goes till vertex 3. Then stops, the blue depth line goes all the way and meets the x again which is the part of the blue depth line. But see the tangent, where the DFS tries to go to the 3 which is already visited but it is not the part of the blue depth line and if its not the part of the current line there is no cycle even if we see a visited node.So cycle detection becomes the trivial task of keeping track of overall visited nodes and the nodes seen in the current depth line.
Keep a separate set to track the nodes in current depth line.def dir_cycle_dfs(adj, curr_depth_line, vertex, vis): vis.add(vertex) curr_depth_line.add(vertex) for nbr in adj[vertex]: if nbr not in vis: if dir_cycle_dfs(adj, curr_depth_line, nbr, vis): return True elif nbr in curr_depth_line: return True curr_depth_line.remove(vertex) # this node &amp; the nodes ahead of it in its depth line have been visited so it is not needed return False
bool dir_cycle_dfs(vector&lt;vector&lt;int&gt;&gt; &amp;adj, unordered_set&lt;int&gt; &amp;curr_depth_line, int vertex, unordered_set&lt;int&gt; &amp;vis){ vis.insert(vertex); curr_depth_line.insert(vertex); for(auto const &amp;nbr: adj){ if(vis.count(nbr) == 0){ if(dir_cycle_dfs(adj, curr_depth_line, nbr, vis)) return true; } else if(curr_depth_line.count(nbr)) return true; } curr_depth_line.erase(nbr); return false;
}
]]></description><link>graphs/cycle-detection.html</link><guid isPermaLink="false">Graphs/Cycle Detection.md</guid><pubDate>Wed, 02 Jul 2025 18:53:25 GMT</pubDate></item><item><title><![CDATA[Breadth First Search (BFS)]]></title><description><![CDATA[This is another kind of graph traversal, in this traversal all the neighbors of a vertex are visited at once before moving on to their neighbors.
It uses queue data structure to achieve this order.
It is one of the most important algorithms in graphs, in my experience even more so than DFS. It follows a minimum order. Means it can be used to find shortest distance between nodes.
It is the same as lever order traversal of trees.
Time complexity of BFS: O(V) space complexity O(V)Below is the implementation of the iterative version of BFS.def bfs(adj, vertex, vis): q = deque() q.append(vertex) vis.add(vertex) while q: node = q.popleft() for neighbor in adj[node]: if neighbor not in vis: vis.add(neighbor) q.append(neighbor)
void bfs(unordered_map&lt;int, vector&lt;int&gt;&gt; &amp;adj, int vertex, unordered_set&lt;int&gt;&amp; vis){ queue&lt;int&gt; q; q.push(vertex); vis.insert(vertex); while(!q.empty()){ int node = q.front(); q.pop(); for(auto const &amp;neighbor: adj[node]){ if(!vis.count(neighbor)){ q.push(neighbor); vis.insert(neighbor); } } }
}
# Snippet created by sameer 21-08-2023
def valid_neighbors(x, y, graph): m, n = len(graph), len(graph[0]) delta = [(-1,0),(0,-1),(0,1),(1,0)] neighbors = [] for dx,dy in delta: r, c = x + dx, y + dy if 0&lt;=r&lt;m and 0&lt;=c&lt;n: neighbors.append((r,c)) return neighbors
def bfs_impl(matrix, vertex, vis): vis.add(vertex) q = deque() q.append(vertex) while q: x, y = q.popleft() for r, c in valid_neighbors(x, y, matrix): if (r, c) not in vis: q.append((r, c)) vis.add((r, c)) vector&lt;pair&lt;int, int&gt;&gt; valid_neighbors(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;graph){ vector&lt;pair&lt;int, int&gt;&gt; neighbors, delta{{{0,-1}, {-1, 0}, {0, 1}, {1, 0}}}; int m = graph.size(), n = graph[0].size(); for(auto const &amp;[dx, dy]: delta){ int r = x + dx, c = y + dy; if(r &gt;=0 and r &lt; m and c &gt;= 0 and c &lt; n) neighbors.push_back({r,c}); } return neighbors;
}
void BFS(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int vertex, vector&lt;vector&lt;bool&gt;&gt; vis)
This is also one of the most frequent topics in the graph theory. It is a variation of implicit BFS In this algorithm we take more than one sources and the BFS progresses simultaneously for those source vertices.
Below Diagram shows the thing visuallyDrawing 2023-08-25 14.07.54.excalidrawThe template below is for multi source BFS.
<a data-href="level order traversal" href=".html" class="internal-link" target="_self" rel="noopener nofollow">level order traversal</a> of binary trees without the null methoddef bfs_multi(matrix, vis): q = deque() m, n = len(matrix), len(matrix[0]) for r in range(m): for c in range(n): if matrix[r][c] == 1: q.append((r, c)) vis.add((r, c)) while q: sz = len(q) # This part is closely related to level wise traversal of trees while sz: sz -= 1 x, y = q.popleft() for r, c in valid_neighbors(x, y, matrix): if (r, c) not in vis: vis.add((r, c)) q.append((r, c))
]]></description><link>graphs/breadth-first-search-(bfs).html</link><guid isPermaLink="false">Graphs/Breadth First Search (BFS).md</guid><pubDate>Wed, 02 Jul 2025 18:53:25 GMT</pubDate></item><item><title><![CDATA[Bubble Sort]]></title><description><![CDATA[<a href=".?query=tag:algorithms" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algorithms">#algorithms</a> <a href=".?query=tag:sorting" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#sorting">#sorting</a> Intuition
I start by taking the first element, I compare it with immediate next element, if its larger I swap them. I go till the end. I again start from the first element, I keep compare-swapping it to its neighbours until end-1 this time
def bubble_sort(arr): for end in range(len(arr) - 1, 0, -1): for i in range(0, end): if arr[i] &gt; arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] ]]></description><link>arrays/bubble-sort.html</link><guid isPermaLink="false">Arrays/Bubble Sort.md</guid><pubDate>Wed, 25 Jun 2025 19:56:25 GMT</pubDate></item><item><title><![CDATA[Selection Sort]]></title><description><![CDATA[<a href=".?query=tag:algorithms" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algorithms">#algorithms</a> <a href=".?query=tag:sorting" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#sorting">#sorting</a> Intuition
I pick up an element, I find out if its the smallest, then exchange it with the first element, now I look up in the rest of the array excluding the first element, if it is smallest I exchange it with position 2
using System.Collections.Generic;
public static void SelectionSort(List&lt;int&gt; collection)
{ if (collection.Count == 0) return; for (int i = 0; i &lt; collection.Count - 1; i++) { int currentMinPos = i; for (int j = i + 1; j &lt; collection.Count; j++) { if (collection[j] &lt; collection[currentMinPos]) { currentMinPos = j; } } // Swap if needed if (currentMinPos != i) { int temp = collection[i]; collection[i] = collection[currentMinPos]; collection[currentMinPos] = temp; } }
}
]]></description><link>arrays/selection-sort.html</link><guid isPermaLink="false">Arrays/Selection Sort.md</guid><pubDate>Wed, 25 Jun 2025 19:48:45 GMT</pubDate></item><item><title><![CDATA[KMP algorithm]]></title><description><![CDATA[Knuth Morris Pratt algorithm is used to find the first occurrence of a substring in a string in O(N + M) time.The core intuition behind this algorithm is that everytime we find a mismatch during our linear search we again go back to the substrings beginning and match it again that results in O(M*N) complexity in the worst case.We maintain an LPS (Longest prefix suffix) array. For each index i in the substring the LPS stores how many characters match from the beginning. In other words it is the longest prefix that is a suffix of the substring of the substring ending at that index.a b c d a b c a This helps us avoid the repeated going back and only go back the necessary amount. suppose we have matched till the second b then we go back only two characters and match from c now because a and b are already matched.# KMP
def createLPS(substring): M = len(substring) lps = [0] * M j, i = 0, 1 while i &lt; M: if substring[i] != substring[j]: j -= lps[i - 1] if substring[i] == substring[j]: lps[i] = j + 1 j += 1 i += 1 return lps
The algorithm is as follows:
Start matching normally using two pointers, everytime there is a mismatch instead of resetting the substring pointer to 0, set it to lps[j - 1]def find(st, sub, lps): M, N = len(sub), len(st) i, j = 0, 0 while i &lt; N: if st[i] == sub[j]: i += 1; j += 1 if j == M: return i - j else: if j != 0: j = lps[j - 1] else: i += 1 return -1
Leetcode: Smallest prefix to make given string palindromic.]]></description><link>strings/kmp-algorithm.html</link><guid isPermaLink="false">Strings/KMP algorithm.md</guid><pubDate>Wed, 25 Jun 2025 19:24:01 GMT</pubDate></item><item><title><![CDATA[Alien Dictionary]]></title><description><![CDATA[<a href=".?query=tag:toposort" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#toposort">#toposort</a> <a href=".?query=tag:graphs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#graphs">#graphs</a> <a href=".?query=tag:bfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bfs">#bfs</a> <a href=".?query=tag:dfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#dfs">#dfs</a>Given a sorted dictionary of an alien language having N words and&nbsp;k starting alphabets of standard dictionary. Find the order of characters in the alien language.
Note:&nbsp;Many orders may be&nbsp;possible for a particular test case, thus&nbsp;you may return any valid order and&nbsp;output will be 1 if the order of string returned by the function is correct else 0 denoting incorrect string returned. &nbsp;Example 1:Input:
N = 5, K = 4
dict = {"baa","abcd","abca","cab","cad"}
Output:
1
Explanation:
Here order of characters is
'b', 'd', 'a', 'c' Note that words are sorted
and in the given language "baa" comes before
"abcd", therefore 'b' is before 'a' in output.
Similarly we can find other orders.Example 2:Input:
N = 3, K = 3
dict = {"caa","aaa","aab"}
Output:
1
Explanation:
Here order of characters is
'c', 'a', 'b' Note that words are sorted
and in the given language "caa" comes before
"aaa", therefore 'c' is before 'a' in output.
Similarly we can find other orders.Your Task:
You don't need to read or print anything. Your task is to complete the function&nbsp;findOrder()&nbsp;which takes&nbsp;&nbsp;the string array dict[], its size N&nbsp;and the integer K as input parameter&nbsp;and returns a string denoting the order of characters in the alien language.Expected Time Complexity:&nbsp;O(N * |S| + K) , where |S| denotes maximum length.
Expected Space Complexity:&nbsp;O(K)Constraints:
1 â‰¤ N, M â‰¤ 300
1 â‰¤ K&nbsp;â‰¤ 26
1 â‰¤ Length of words&nbsp;â‰¤ 50This question seems impossible at first, but if you read the question like this, the intuition appears to be more clear.
Find the ordering of the alphabets such that if a word w1 appears after the word w2 due to the alphabet x &lt; y then x should come before y in the ordering.
This seems oddly familiar to the topological sorting that we have done earlier.Building The Graph
Now that we have thought that we may be able to use toposort to solve this problem, How exactly do I make the graph. It is also hidden in the above intuition line, There is an edge between x and y if two words w1 and w2 differ by x &amp; y and w1 comes before w2 that means there is an edge from x to y.def kahn_toposort(adj): # finding the indegrees indegrees = {v: 0 for v in adj.keys()} for nbrs in adj.values(): for nbr in nbrs: indegrees[nbr] += 1 q = deque() toposort = [] for v, indegree in indegrees.items(): if indegree == 0: q.append(v) # kind of like a multi source bfs while q: curr = q.popleft() toposort.append(curr) for nbr in adj[curr]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: q.append(nbr) # print(toposort) return toposort class Solution: def findOrder(self,alien_dict, N, K): # building the graph adj = {chr(ord('a') + i):[] for i in range(K)} for w1, w2 in pairwise(alien_dict): for char1, char2 in zip(w1, w2): if char1 != char2: adj[char1].append(char2) break # only first unequal letter is responsible for order return kahn_toposort(adj) ]]></description><link>problems/gfg/alien-dictionary.html</link><guid isPermaLink="false">Problems/GFG/Alien Dictionary.md</guid><pubDate>Wed, 25 Jun 2025 19:23:59 GMT</pubDate></item><item><title><![CDATA[Red and Black Trees]]></title><link>trees/red-and-black-trees.html</link><guid isPermaLink="false">Trees/Red and Black Trees.md</guid><pubDate>Wed, 25 Jun 2025 19:21:02 GMT</pubDate></item><item><title><![CDATA[Problems]]></title><link>tries/problems.html</link><guid isPermaLink="false">Tries/Problems.md</guid><pubDate>Wed, 25 Jun 2025 19:21:02 GMT</pubDate></item><item><title><![CDATA[Roadmap Resources]]></title><link>miscellaneous/resources/roadmap-resources.html</link><guid isPermaLink="false">Miscellaneous/Resources/Roadmap Resources.pdf</guid><pubDate>Wed, 25 Jun 2025 19:21:02 GMT</pubDate></item><item><title><![CDATA[04-greedy]]></title><link>miscellaneous/resources/04-greedy.html</link><guid isPermaLink="false">Miscellaneous/Resources/04-greedy.pdf</guid><pubDate>Wed, 25 Jun 2025 19:21:02 GMT</pubDate></item><item><title><![CDATA[Strongly Connected Components]]></title><link>graphs/strongly-connected-components.html</link><guid isPermaLink="false">Graphs/Strongly Connected Components.md</guid><pubDate>Wed, 25 Jun 2025 19:21:02 GMT</pubDate></item></channel></rss>